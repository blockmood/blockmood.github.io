[{"title":"Custom Link","date":"2017-11-02T00:12:24.000Z","path":"2017/11/02/Custom Link/","text":"12345678910111213141516171819202122232425262728293031323334353637383940import React from &apos;react&apos;import &#123; BrowserRouter as Router, Route, Link&#125; from &apos;react-router-dom&apos;const CustomLinkExample = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;OldSchoolMenuLink activeOnlyWhenExact=&#123;true&#125; to=&quot;/&quot; label=&quot;Home&quot;/&gt; &lt;OldSchoolMenuLink to=&quot;/about&quot; label=&quot;About&quot;/&gt; &lt;hr/&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt; &lt;/div&gt; &lt;/Router&gt;)const OldSchoolMenuLink = (&#123; label, to, activeOnlyWhenExact &#125;) =&gt; ( &lt;Route path=&#123;to&#125; exact=&#123;activeOnlyWhenExact&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;div className=&#123;match ? &apos;active&apos; : &apos;&apos;&#125;&gt; &#123;match ? &apos;&gt; &apos; : &apos;&apos;&#125;&lt;Link to=&#123;to&#125;&gt;&#123;label&#125;&lt;/Link&gt; &lt;/div&gt; )&#125;/&gt;)const Home = () =&gt; ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt;)const About = () =&gt; ( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;/div&gt;)export default CustomLinkExample 参考链接 Custom Link","tags":[{"name":"react-router","slug":"react-router","permalink":"http://yoursite.com/tags/react-router/"}]},{"title":"配置SSH Keys","date":"2017-11-01T04:11:24.000Z","path":"2017/11/01/配置SSH Keys/","text":"SSH密钥是一个用来识别值得信赖的电脑在进行GitHub一些操作时,不用输入密码。用户可以生成一个SSH密钥，并按照本节所述的方法将公共密钥添加到你的GitHub帐户。 我们建议你定期检查SSH密钥列表，并删除任何一个长时间没有使用的秘钥. 小贴士:如果你安装的有GitHub的桌面版 ，你可以用它来克隆库而不是进行SSH密钥处理。它还配备了Git的Bash的工具，这是在Windows上运行的git命令的首选方式。 检测电脑中是否已有SSH 秘钥查看是否存在SSH秘钥1ls -al ~/.ssh 默认情况下,公共秘钥的文件名是下列之一:1234id_dsa.pubid_ecdsa.pubid_ecdsa.pubid_ecdsa.pub 如果没有一个现有的公共和私有密钥，或者不希望使用任何可用的SSH秘钥来连接到GitHub上，请生成一个新的SSH密钥。 生成新的SSH密钥并将其添加到ssh-agent中 输入ssh-keygen -t rsa -b 4096 -C “your_email@example.com” (将邮箱替换为你自己的地址) 1$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; # Creates a new ssh key, using the provided email as a label Generating public/private rsa key pair. 当你提示“输入要保存密钥的文件”，然后按Enter键。接受默认文件位置。 1Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] 在提示符下，键入一个安全密码(可以为空)。有关详细信息，请参阅“使用SSH密钥口令”一节。 1Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 将ssh秘钥添加到 ssh-agent,在任意目录右键,选择Git Bash后输入命令确保ssh-agent的启用 1start the ssh-agent in the background $ eval &quot;$(ssh-agent -s)&quot; Agent pid 59566 添加你的SSH密钥到ssh-agent 。如果你使用现有的SSH密钥，而不是生成新的SSH密钥，你需要替换现有的私有密钥文件的名称，以取代id_rsa的命令。 1$ ssh-add ~/.ssh/id_rsa","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"react以函数为子组件","date":"2017-10-26T07:10:24.000Z","path":"2017/10/26/react以函数为子组件/","text":"代理方式的高阶组件react高阶组件不是唯一可用于提高组件代码重用的方法，高阶组件扩展现有组件功能的方式主要是通过props，以代理方式的高阶组件为例子，新产生的组件和原有的组件说到底是父子关系的组件，而俩个组件之间的通信自然是props,看下面的代码 1234567891011import React from &apos;react&apos;;const addNewProps = (WrappedComponent, newProps) =&gt; &#123; return class WrappingComponent extends React.Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt; &#125; &#125;&#125;export default addNewProps; 如果要使用这个组件，作为参数的组件必须要能够接受名为 newProps 的prop，不然应用这个组件就完全没有意义，这就是代理组件的一个缺点，对原有组件的props有了固化的要求。 以函数为子组件以函数为子组件就是为了克服这种局限性的，在这种模式下，实现代码重用的不是一个函数，而是一个真正的react组件，这样的组件有一个特点，就是要求必须有子组件的存在，而且这个子组件必须是一个函数。在实例的生命周期中，this.props.children()引用的就是子组件，render函数会直接把this.props.children当做函数来调用，得到的结果就可以作为render函数返回结果的一部分。 12345678910111213141516import React from &apos;react&apos;;const loggedinUser = &apos;mock user&apos;;class AddUserProp extends React.Component &#123; render() &#123; const user = loggedinUser; return this.props.children(user) &#125;&#125;AddUserProp.propTypes = &#123; children: React.PropTypes.func.isRequired&#125;export default AddUserProp; 使用这个组件的灵活之处在于他没有被对增强的组件有任何的props的要求，只是传递过去一个参数，至于使用的话 例如：我们想让一个组件吧user显示出来 12345&lt;AddUserProp&gt; &#123; (user)=&gt; &lt;div&gt;&#123;user&#125;&lt;/div&gt; &#125;&lt;/AddUserProp&gt; 又例如：我们想吧user传递给另外一个Foo组件 12345&lt;AddUserProp&gt; &#123; (user)=&gt; &lt;Foo user=&#123;user&#125; /&gt; &#125;&lt;/AddUserProp&gt; 可以看到，使用函数为子组件非常灵活。","tags":[{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"关于段子","date":"2017-10-19T02:10:24.000Z","path":"2017/10/19/不错的段子/","text":"你不必把这杯白酒干了，喝到胃穿孔，也不会获得帮助，不会获得尊重。你不必放弃玩音乐，不必出专辑，也不必放弃工作，不必介意成为一个带着奶瓶的朋克。 你不必在本子上记录，大部分会议是在浪费时间，你不必假装殷勤一直记录。你不必总是笑，不必每一条微信都回复，不必处处点赞。 你不必有什么户口，也不必要求别人要有什么户口。即便生存不易，也不必让爸妈去相亲角被别人盘问出身。你不必买大房子，不必在月薪一万的时候就贷款三百万。三十年后，当孩子们问起那些年你有什么故事，你不能只有贷款。 你不必去知名的大公司追求梦想，你想逃离的种种，在那里同样会有。你不必去大城市，也不必逃离北上广。不必用别人的一篇十万加，来决定自己的一辈子。 你不必改变自己。不必相信一万小时定律，不必读成功学，不必加入高管群，不必成为第二个什么人。你不必听狭隘女权主义者的杂音，不必理会那些只要求特权，却不尽义务的人。你不必用睡过多少女孩，来证明魅力。这不值得炫耀，而且你并不知道是谁睡了谁。 你不必让所有人都开心。不必每次旅游都要带礼物，不必一次不落的随份子，不必在饭桌上辛苦地计算座次。你不必在过年的时候衣锦还乡。不必发那么大的红包，不必开车送每一个人回家。 你不必承担所有责任。不必为拒绝借钱给朋友而过意不去，不必为父母的节俭而内疚，不必向路边的每一个乞讨者伸出援手。你不必刻意追求什么彼岸和远方，每一个你想抵达的地方，都有人和你一样想逃离。你不必在深夜停车之后，在楼下抽支烟再回家。 你不必背负这么多，你不必成功。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"关于思考","date":"2017-10-15T02:10:24.000Z","path":"2017/10/15/关于思考/","text":"早上起来看到一个话题就是，现在这个点呢离2017年结束还剩下大概不到85天的时间，那么我也左思右想该写点什么来总结一下这一年的情况，于是也就有了下文，本文借鉴于 GuojinH5 ，水平有限，读不懂还请多多体谅。 我也围绕以下几个点，还说说我目前的一个状况。 [梦想] [生活] [工作] [未来] 梦想梦想这种东西越长大越坚定自己以前没有过，从小时候的梦想是让我的同桌做我老婆、做超人，每天有肉吃、每天有动画片看、有很多玩具、每个课间空都有钱去买包辣条吃、快点长大、会飞、每天买一本小人书、弹弹珠的时候不会输等等的这些，到后来的要有稳定的工作、有爱自己的爱人、家人身体安康，每天开开心心的。扯了这么多没用的，我想说的是，其实梦想就是寄给将来的自己的那一封情书，是活成自己的一个唯一凭证。 生活生活的话肯定是越来越好，也算是实现了当年的梦想，每天有肉吃，以至于我到北京后从130直升150多，这也就成了某些人口中的胖子这一说，其实我对这些东西倒是无所谓，男人嘛，胖点总是好的，总比还不到100多的男人好吧？最起码有安全感是不是？不过我比较怀念家里边的饭菜，最起码干净，饭店的饭吃腻了，每天还真不知道该吃点什么好。身体的话也是大不如从前了，从以前打篮球能不休息打一天到现在打半个小时就休息好几个小时的过程，这大概也就6年的时间，说实话我现在不生病完全取决于我以前的身体素质，如果要是靠现在的话我也就只能呵呵了，不过现在有时间还是要出去跑跑步，打打球，反正已经这样了，不能再让他坏下去吧。以前跟朋友通宵一晚上打游戏都不累的，到现在玩到11多12点就不想玩了，一是觉得没什么意思，二是太累，扛不住啊。现在越来越喜欢安静了，不太喜欢乱七八糟的生活，越来越想回农村，农村套路少啊，哈哈。说了这么多，归根结底还是每天早睡早起，吃早饭，然后就继续这样着。 工作我接触这个行业，完全取决于我大学的一个老师，他是搞Java的，我也学过Java，什么SSH框架乱七八糟的，当时大学自学了大概俩年时间，也做了一些乱七八糟的小系统，（我当时可是认为自己是很牛逼的），我当时毕业论文的时候一个邮编系统，说了乱七八糟的一系列术语，什么数据库，什么外键索引的，当时那几个老师一脸懵逼的表情我现在还能记得，可能因为当时自己学习的不系统，而且太注重于功能的实现，导致自己没有学到很多精髓，还有自己天资不是很高，后来就没有继续下去，不过没事，也正是有了这些基础，到后来的我搞后台很快能上手，（原理都差不多嘛）。现在的话还是要加强学习，以至于今年也看了好几本不同的技术书，（以前的我哪能看进去啊），我打算以后都这样，继续学习，继续深造，有一句话说的很好，只要路是对的，不怕远。 未来今年的目标大部分也都实现了，还缺个mac还没买，过几天吧哈哈，以后的话肯定会更好，慢慢的就是越来越稳定，然后结婚等等一系列的问题，问题都来吧，一个一个总会解决。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"完全理解React高阶组件（Higher-Order Components）","date":"2017-10-13T02:10:24.000Z","path":"2017/10/13/完全理解React高阶组件（Higher-Order Components）/","text":"高阶组件定义 a higher-order component is a function that takes a component and returns a new component. 翻译：高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。 理解了吗？看了定义似懂非懂？继续往下看。 函数模拟高阶组件我们通过普通函数来理解什么是高阶组件哦~ 1.最普通的方法，一个welcome，一个goodbye。两个函数先从localStorage读取了username，然后对username做了一些处理。 123456789101112function welcome() &#123; let username = localStorage.getItem(&apos;username&apos;); console.log(&apos;welcome &apos; + username);&#125;function goodbey() &#123; let username = localStorage.getItem(&apos;username&apos;); console.log(&apos;goodbey &apos; + username);&#125;welcome();goodbey(); 2.我们发现两个函数有一句代码是一样的，这叫冗余唉。不好不好~（你可以把那一句代码理解成平时的一大堆代码）我们要写一个中间函数，读取username,他来负责把username传递给两个函数。 123456789101112131415161718192021function welcome(username) &#123; console.log(&apos;welcome &apos; + username);&#125;function goodbey(username) &#123; console.log(&apos;goodbey &apos; + username);&#125;function wrapWithUsername(wrappedFunc) &#123; let newFunc = () =&gt; &#123; let username = localStorage.getItem(&apos;username&apos;); wrappedFunc(username); &#125;; return newFunc;&#125;welcome = wrapWithUsername(welcome);goodbey = wrapWithUsername(goodbey);welcome();goodbey(); 好了，我们里面的wrapWithUsername函数就是一个“高阶函数”。他做了什么？他帮我们处理了username，传递给目标函数。我们调用最终的函数welcome的时候，根本不用关心username是怎么来的。我们增加个用户study函数。123456function study(username)&#123; console.log(username+&apos; study&apos;);&#125;study = wrapWithUsername(study);study(); 这里你是不是理解了为什么说wrapWithUsername是高阶函数？我们只需要知道，用wrapWithUsername包装我们的study函数后，study函数第一个参数是username。 我们写平时写代码的时候，不用关心wrapWithUsername内部是如何实现的。 高阶组件高阶组件就是一个没有副作用的纯函数。 我们把上一节的函数统统改成react组件。 welcome函数转为react组件。 12345678910111213141516171819202122232425import React, &#123;Component&#125; from &apos;react&apos;class Welcome extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; username: &apos;&apos; &#125; &#125; componentWillMount() &#123; let username = localStorage.getItem(&apos;username&apos;); this.setState(&#123; username: username &#125;) &#125; render() &#123; return ( &lt;div&gt;welcome &#123;this.state.username&#125;&lt;/div&gt; ) &#125;&#125;export default Welcome; goodbey函数转为react组件。 12345678910111213141516171819202122232425import React, &#123;Component&#125; from &apos;react&apos;class Goodbye extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; username: &apos;&apos; &#125; &#125; componentWillMount() &#123; let username = localStorage.getItem(&apos;username&apos;); this.setState(&#123; username: username &#125;) &#125; render() &#123; return ( &lt;div&gt;goodbye &#123;this.state.username&#125;&lt;/div&gt; ) &#125;&#125;export default Goodbye; 现在你是不是更能看到问题所在了？两个组件大部分代码都是重复的,按照上一节wrapWithUsername函数的思路，我们来写一个高阶组件(高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件)。 12345678910111213141516171819202122232425import React, &#123;Component&#125; from &apos;react&apos;export default (WrappedComponent) =&gt; &#123; class NewComponent extends Component &#123; constructor() &#123; super(); this.state = &#123; username: &apos;&apos; &#125; &#125; componentWillMount() &#123; let username = localStorage.getItem(&apos;username&apos;); this.setState(&#123; username: username &#125;) &#125; render() &#123; return &lt;WrappedComponent username=&#123;this.state.username&#125;/&gt; &#125; &#125; return NewComponent&#125; 这样我们就能简化Welcome组件和Goodbye组件。 123456789101112131415import React, &#123;Component&#125; from &apos;react&apos;;import wrapWithUsername from &apos;wrapWithUsername&apos;;class Welcome extends Component &#123; render() &#123; return ( &lt;div&gt;welcome &#123;this.props.username&#125;&lt;/div&gt; ) &#125;&#125;Welcome = wrapWithUsername(Welcome);export default Welcome; 123456789101112131415import React, &#123;Component&#125; from &apos;react&apos;;import wrapWithUsername from &apos;wrapWithUsername&apos;;class Goodbye extends Component &#123; render() &#123; return ( &lt;div&gt;goodbye &#123;this.props.username&#125;&lt;/div&gt; ) &#125;&#125;Goodbye = wrapWithUsername(Goodbye);export default Goodbye; 看到没有，高阶组件就是把username通过props传递给目标组件了。目标组件只管从props里面拿来用就好了。 到这里位置，高阶组件就讲完了。你再返回去理解下定义，是不是豁然开朗~ 你现在理解react-redux的connect函数~ 把redux的state和action创建函数，通过props注入给了Component。你在目标组件Component里面可以直接用this.props去调用redux state和action创建函数了。 1ConnectedComment = connect(mapStateToProps, mapDispatchToProps)(Component); 相当于这样 12345// connect是一个返回函数的函数（就是个高阶函数）const enhance = connect(mapStateToProps, mapDispatchToProps);// 返回的函数就是一个高阶组件，该高阶组件返回一个与Redux store// 关联起来的新组件const ConnectedComment = enhance(Component); antd的Form也是一样的 1const WrappedNormalLoginForm = Form.create()(NormalLoginForm); 参考地址： http://huziketang.com/books/react/lesson28 https://react.bootcss.com/react/docs/higher-order-components.html","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"利用reselect提高数据获取性能","date":"2017-10-12T07:10:24.000Z","path":"2017/10/12/利用reselect来缓存数据/","text":"首先安装对应的包1npm install --save reselect 原理：只要相关状态没有改变，那就直接使用上一次的缓存结果 123456789101112131415161718192021import &#123;createSelector&#125; from &apos;reselect&apos;;import &#123;FilterTypes&#125; from &apos;../constants.js&apos;;const getFilter = (state) =&gt; state.filter;const getTodos = (state) =&gt; state.todos;export const selectVisibleTodos = createSelector( [getFilter, getTodos], (filter, todos) =&gt; &#123; switch (filter) &#123; case FilterTypes.ALL: return todos; case FilterTypes.COMPLETED: return todos.filter(item =&gt; item.completed); case FilterTypes.UNCOMPLETED: return todos.filter(item =&gt; !item.completed); default: throw new Error(&apos;unsupported filter&apos;); &#125; &#125;); reselect 提供了createSelector函数选择器，这是高阶函数，也就是接收函数作为参数来产生一个新函数的函数。createSelector第一个参数是一个函数数组，每个元素代表了选择器需要做的映射计算（这里原理是当前的状态和之前的状态做比较，如果相同，就把数据缓存起来，就不会执行第二个函数，如果不同，才会执行第二个函数做重新计算），例子里提供了俩个函数getFilter和getTodos，对应代码12const getFilter = (state) =&gt; state.filter;const getTodos = (state) =&gt; state.todos; createSelector第二个参数代表的是一个计算过程，参数为第一个参数的输出结果。 Redux要求每个reducer不能修改state的状态，如果要返回一个新的状态，就必须返回一个新的对象。如此一来，Redux Store状态树上的某一个节点如果没有变化，那么这个节点下的数据就肯定没有变化，应用在reselect中，也就是第一个参数的原理，直接缓存运算结果。","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react组件该如何写","date":"2017-10-10T07:10:24.000Z","path":"2017/10/10/react组件函数式还是模块式区分/","text":"书中写了好多种react组件的书写方式，我这里大概总结了俩种，工作中也就围绕这俩种展开来的。 函数式函数式的编写方法一般是当前组件基本没有任何业务逻辑可言，仅仅就只是用来做展示的功能，大概看如下组件 123456789101112131415import React from &apos;react&apos;const TodoItem = (&#123;text,completed,onToggle,onRemove&#125;) =&gt;&#123; return ( &lt;li style=&#123;&#123;textDecoration:completed ? &apos;line-through&apos; : &apos;none&apos;&#125;&#125; &gt; &lt;input type=&quot;checkbox&quot; checked=&#123;completed&#125; readOnly onClick=&#123;onToggle&#125;/&gt; &#123;text&#125; &lt;button onClick=&#123;onRemove&#125;&gt;x&lt;/button&gt; &lt;/li&gt; )&#125;export default TodoItem 那么这个组件完全只是用来展示当前的列表，用不到任何业务逻辑，有几个简单的业务逻辑也可以直接传递给父组件，让父组件代替实现。 es6模块式这种方式的话比较通用，上面的组件功能当然能实现，但是肯定是会有一些多余的代码，比如constructor构造等等，但是如果项目中通用这种方式的话，起码能保证项目不会出错，目前分析的话有的组件业务逻辑较多，推荐用这种方式，大概看下面的组件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from &apos;react&apos;import &#123;connect&#125; from &apos;react-redux&apos;import &#123;addTodo&#125; from &apos;../actions.js&apos;class AddTodo extends React.Component&#123; constructor()&#123; super(...arguments) this.add = this.add.bind(this) this.refInput = this.refInput.bind(this) &#125; add()&#123; if(!this.input.value.trim())&#123; return &#125; this.props.onAdd(this.input.value) this.input.value = &apos;&apos; &#125; refInput(node)&#123; this.input = node &#125; render()&#123; return ( &lt;div&gt; &lt;input ref=&#123;this.refInput&#125;/&gt; &lt;button onClick=&#123;this.add&#125;&gt;add&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onAdd:(text)=&gt;&#123; dispatch(addTodo(text)) &#125; &#125;&#125;export default connect(null,mapDispatchToProps)(AddTodo) 上面的组件有用户的点击 输入等等业务逻辑，比函数式更通用，代码更清晰。","tags":[{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"redux等插件配置","date":"2017-09-22T02:10:24.000Z","path":"2017/09/22/redux等插件配置/","text":"插件列表 React Devtools 可以检验react组件的树形结构 Redux Devtools 可以检视Redux数据流 React Perf 可以发现React组件渲染性能问题 代码配置1234567891011121314151617181920212223242526import &#123;createStore, combineReducers, applyMiddleware, compose&#125; from &apos;redux&apos;;import &#123;reducer as todoReducer&#125; from &apos;./todos&apos;;import &#123;reducer as filterReducer&#125; from &apos;./filter&apos;;import Perf from &apos;react-addons-perf&apos;const win = window;win.Perf = Perfconst reducer = combineReducers(&#123; todos: todoReducer, filter: filterReducer&#125;);const middlewares = [];if (process.env.NODE_ENV !== &apos;production&apos;) &#123; middlewares.push(require(&apos;redux-immutable-state-invariant&apos;)());&#125;const storeEnhancers = compose( applyMiddleware(...middlewares), (win &amp;&amp; win.devToolsExtension) ? win.devToolsExtension() : (f) =&gt; f,);export default createStore(reducer, &#123;&#125;, storeEnhancers);","tags":[{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"redux","date":"2017-09-13T16:10:24.000Z","path":"2017/09/14/redux/","text":"工作流程 1.用户通过dispath发出Action 2.Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。 3.State 一旦有变化，Store 就会调用监听函数subscribe。","tags":[{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"react-redux","date":"2017-09-13T16:10:24.000Z","path":"2017/09/14/react-redux/","text":"react-redux提供了俩个最主要的功能 connect : 连接容器组件和展示组件 Provider: 提供包含store的context Provider在组件中导入store是非常不利于复用的，所以react提供了一个叫context的功能，能够完美解决这个问题。 因为redux应用中只有一个store，因此所有的组件如果要使用store的话，只能访问这唯一的store,很自然，希望顶层的组件来扮演这个context提供者的角色，只要顶层组件提供包含store的context，那就覆盖了整个应用的所有组件。 创建Provider.js 1234567891011121314151617181920import &#123;PropTypes,Component&#125; from &apos;react&apos;class Provider extends Component&#123; getChildContext()&#123; //这个函数返回的就是代表context对象 return &#123; store:this.props.store &#125; &#125; render()&#123; return this.props.children //把渲染的工作交给子组件 &#125;&#125;Provider.childContextTypes = &#123; store: PropTypes.object&#125;;export default Provider 然后再入口文件 123&lt;Provider store=&#123;store&#125;&gt; &lt;CounterPanel /&gt;&lt;/Provider&gt; 底层组件使用 为了让底层组件能够访问到context，必须给context-Types的类型和Provider.childContextTypes一样的值，俩者必须一致，不然就无法访问到context 123CounterContainer.contextTypes = &#123; store: PropTypes.object&#125; 还有构造函数里面必须带上context这个参数 123constructor(props,context)&#123; super(props,context)&#125; 然后我们就可以通过this.context.store来访问这个store connect1export default connect(mapStateToTypes, mapDispatchToTypes)(Counter); connect是react-redux提供的一个方法，这个方法接收俩个参数，mapStateToTypes和mapDispatchToTypes，执行结果依然是一个函数，然后才可以再后面又加一个括号，这个括号里面就是展示组件。 这个函数做了什么呢？作为一个容器组件，做的事情无外乎就是俩件事情。 1.把store上的状态转化为内层展示组件的props 2.把内存展示组件中的用户动作转化为派送给store的动作。","tags":[{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"webpack之代理请求接口","date":"2017-08-04T05:12:24.000Z","path":"2017/08/04/webpack之代理请求接口/","text":"前提依赖axios，1var axios = require('axios') 原理大概为 去们请求axios服务，axios伪造host等信息请求数据，大概配置如下： 123456789101112131415161718//请求代理var apiRoutes = express.Router()apiRoutes.get('/getDiscList', function (req, res) &#123; var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg' axios.get(url, &#123; headers: &#123; referer: 'https://c.y.qq.com/', host: 'c.y.qq.com' &#125;, params: req.query &#125;).then((response) =&gt; &#123; res.json(response.data) &#125;).catch((e) =&gt; &#123; console.log(e) &#125;)&#125;)app.use('/api',apiRoutes)","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"JavaScript Async/Await","date":"2017-08-01T08:10:24.000Z","path":"2017/08/01/JavaScript Async . Await/","text":"什么是Async/Await？Async/Await是一个很久就令人期待的JavaScript功能，它让使用异步函数更加愉快和容易理解。它是基于Promises的并且和现存的所有基于Promises的API相兼容。 从async和await这两个名字来的这两个关键字将会帮助我们整理我们的异步代码。 Async - 声明一个异步函数（async function someName(){…}）。 自动将一个常规函数转化为一个Promise。 当调用async函数的时候，它用函数内返回的任何值来解决（resolve）。 异步函数可以使用await Await-暂停执行async函数（var result = await someAsyncCall();）。 当放在一个Promise前面执行，await强制剩下的代码等待直到那个Promise结束并且返回一个结果 Await只有和Promise一起使用才有用，和回调函数（普通函数）一起使用不会产生作用 Await只可以在async函数内部使用 这里有一个简单的例子，希望能帮你把事情理清楚： 假设我们想从我们的服务器中得到一些JSON文件。我们将写一个函数用axios库发送一个http GET 请求到https://tutorialzine.com/misc/files/example.json。 我们不得不等待服务器响应，所以很自然这个HTTP 请求是异步的。 下面我们可以看到相同的功能实现了两次。首先是用Promises，然后第二次用Async / Await。 123456789101112131415161718192021222324// Promise 实现方式function getJSON()&#123; // 为了让函数阻塞我们手动创建了一个Promise return new Promise( function(resolve) &#123; axios.get('https://tutorialzine.com/misc/files/example.json') .then( function(json) &#123; // 从请求来的数据可以从.then中得到 // 我们使用resolve返回结果 resolve(json); &#125;); &#125;);&#125;// Async/Await 实现方式// async关键字将会自动创建一个新的Promise并返回。async function getJSONAsync()&#123; // await关键词使我们免于写一个.then() let json = await axios.get('https://tutorialzine.com/misc/files/example.json'); // GET请求的结果可以从json变量中得到 // 我们把结果就像一个普通的同步函数一样返回 return json;&#125; 很明显Async/Await版本的代码更短并且可读性更强。除了使用的语法，两个函数完全相同-他们都返回Promises并且都从axios得到JSON返回。我们可以像这样调用我们的async函数： 123getJSONAsync().then( function(result) &#123; // Do something with result.&#125;); 那么，Async/Await 让 Promises 过时了吗？一点也不，当我们使用Async/Await其实底层还是在使用Promises。对Promises的良好理解在长远考虑下是对你是十分有帮助的并且也是高度推荐的。 这里甚至有一些情况Async/Await不能解决而我们不得不重新去寻求Promises的帮助。一种这样的场景是我们需要去调用多个独立的异步函数并等待他们所有完成。 假如我们尝试用async and await，以下就会发生: 123456async function getABC() &#123; let A = await getValueA(); // getValueA takes 2 second to finish let B = await getValueB(); // getValueB takes 4 second to finish let C = await getValueC(); // getValueC takes 3 second to finish return A*B*C;&#125; 每一个await将会等待前一个返回一个结果。因为我们一次只执行一个调用那么整个函数从开始到结束将会花9秒的时间（2+4+3）。 这不是一个最佳的解决方案，因为A,B和C互相并不依赖。换句话来说我们在得到B的时候我们并不需要A的值。我们可以同时得到这些值以减去几秒钟的等待时间。 同时发送所有的requests我们需要Promise.all()。这将会保证我们在进行下一步的时候我们可以得到所有的结果，但是所有的异步函数将会平行的运行，而不是一个接一个。 123456async function getABC() &#123; // Promise.all() allows us to send all requests at the same time. let results = await Promise.all([ getValueA, getValueB, getValueC ]); return results.reduce((total,value) =&gt; total * value);&#125; 这种方式函数将会花费少的多的时间，在getValueB结束的时候getValueA和getValueC就已经结束了。我们将有效的减少执行的时间到最慢的请求而不是时间的总和。 处理Async/Await的错误另一个关于Async/Await很棒的事是它允许我们用很棒的老式try/catch块去catch任何意外的错误。 123456789async function doSomethingAsync()&#123; try &#123; // This async call may fail. let result = await someAsyncCall(); &#125; catch(error) &#123; // If it does we will catch the error here. &#125; &#125; 任何我们写在try块中的等待的异步调用或者其他任何错误代码，catch都能解决他们引起的错误（error）。 如果情况需要，我们也可以在执行async函数的时候抓取错误。由于所有异步函数返回Promises，所以我们可以在调用它们时简单地包含.catch()事件处理程序。 1234567891011// 不包含try/catch块的async函数async function doSomethingAsync()&#123; // 这个async调用也许会失败 let result = await someAsyncCall(); return result; &#125;// 我们catch错误在调用async函数的时候doSomethingAsync(). .then(successHandler) .catch(errorHandler); 重要的是选择一种你喜欢的错误处理的方式，并坚持使用它。同时使用try/catch和.catch(）将很有可能导致一些问题。 浏览器支持Async/Await已经支持大部分的主流浏览器。绝大多数的厂商将会识别你的async/await代码而不需要额外的库-除了IE11. Node开发者只要node8或以上就可以享受到改进的异步流。它在今年晚些时候应该会变成LTS（ Long Term Support ）版本。 如果这兼容性不能满足你，也有许多像Babel和TypeScript和Nodejs库asyncawait这样的JS transpiler（源码转换器）提供他们自己的跨平台版本的功能。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"axios","date":"2017-07-27T05:10:24.000Z","path":"2017/07/27/axios/","text":"例子 1、 发送一个GET请求 1234567891011121314151617181920//通过给定的ID来发送请求axios.get('/user?ID=12345') .then(function(response)&#123; console.log(response); &#125;) .catch(function(err)&#123; console.log(err); &#125;);//以上请求也可以通过这种方式来发送axios.get('/user',&#123; params:&#123; ID:12345 &#125;&#125;).then(function(response)&#123; console.log(response);&#125;).catch(function(err)&#123; console.log(err);&#125;); 2、 发送一个POST请求 12345678910axios.post('/user',&#123; firstName:'Fred', lastName:'Flintstone'&#125;).then(function(res)&#123; console.log(res);&#125;).catch(function(err)&#123; console.log(err);&#125;); 3、 一次性并发多个请求 12345678910function getUserAccount()&#123; return axios.get('/user/12345');&#125;function getUserPermissions()&#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms)&#123; //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果 &#125;)) axios的API（一） axios可以通过配置（config）来发送请求 1、 axios(config) 123456789//发送一个`POST`请求axios(&#123; method:\"POST\", url:'/user/12345', data:&#123; firstName:\"Fred\", lastName:\"Flintstone\" &#125;&#125;); 2、 axios(url[,config]) 12//发送一个`GET`请求（默认的请求方式）axios('/user/12345'); （二）、 请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名12345678910111213axios.request(config);axios.get(url[,config]);axios.delete(url[,config]);axios.head(url[,config]);axios.post(url[,data[,config]]);axios.put(url[,data[,config]])axios.patch(url[,data[,config]]) 注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明 （三）、并发请求（concurrency）,即是帮助处理并发请求的辅助函数1234//iterable是一个可以迭代的参数如数组等axios.all(iterable)//callback要等到所有请求都完成才会执行axios.spread(callback) （四）、创建一个axios实例，并且可以自定义其配置 1、 axios.create([config]) 12345var instance = axios.create(&#123; baseURL:\"https://some-domain.com/api/\", timeout:1000, headers: &#123;'X-Custom-Header':'foobar'&#125;&#125;); 2、 实例的方法 一下是实例方法，注意已经定义的配置将和利用create创建的实例的配置合并12345678910111213axios#request(config)axios#get(url[,config])axios#delete(url[,config])axios#head(url[,config])axios#post(url[,data[,config]])axios#put(url[,data[,config]])axios#patch(url[,data[,config]]) 四、请求的配置（request config）以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&#123; //`url`是请求的服务器地址 url:'/user', //`method`是请求资源的方式 method:'get'//default //如果`url`不是绝对地址，那么`baseURL`将会加到`url`的前面 //当`url`是相对地址的时候，设置`baseURL`会非常的方便 baseURL:'https://some-domain.com/api/', //`transformRequest`选项允许我们在请求发送到服务器之前对请求的数据做出一些改动 //该选项只适用于以下请求方式：`put/post/patch` //数组里面的最后一个函数必须返回一个字符串、-一个`ArrayBuffer`或者`Stream` transformRequest:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`transformResponse`选项允许我们在数据传送到`then/catch`方法之前对数据进行改动 transformResponse:[function(data)&#123; //在这里根据自己的需求改变数据 return data; &#125;], //`headers`选项是需要被发送的自定义请求头信息 headers: &#123;'X-Requested-With':'XMLHttpRequest'&#125;, //`params`选项是要随请求一起发送的请求参数----一般链接在URL后面 //他的类型必须是一个纯对象或者是URLSearchParams对象 params: &#123; ID:12345 &#125;, //`paramsSerializer`是一个可选的函数，起作用是让参数（params）序列化 //例如(https://www.npmjs.com/package/qs,http://api.jquery.com/jquery.param) paramsSerializer: function(params)&#123; return Qs.stringify(params,&#123;arrayFormat:'brackets'&#125;) &#125;, //`data`选项是作为一个请求体而需要被发送的数据 //该选项只适用于方法：`put/post/patch` //当没有设置`transformRequest`选项时dada必须是以下几种类型之一 //string/plain/object/ArrayBuffer/ArrayBufferView/URLSearchParams //仅仅浏览器：FormData/File/Bold //仅node:Stream data &#123; firstName:\"Fred\" &#125;, //`timeout`选项定义了请求发出的延迟毫秒数 //如果请求花费的时间超过延迟的时间，那么请求会被终止 timeout:1000, //`withCredentails`选项表明了是否是跨域请求 withCredentials:false,//default //`adapter`适配器选项允许自定义处理请求，这会使得测试变得方便 //返回一个promise,并提供验证返回 adapter: function(config)&#123; /*..........*/ &#125;, //`auth`表明HTTP基础的认证应该被使用，并提供证书 //这会设置一个authorization头（header）,并覆盖你在header设置的Authorization头信息 auth: &#123; username:\"zhangsan\", password: \"s00sdkf\" &#125;, //返回数据的格式 //其可选项是arraybuffer,blob,document,json,text,stream responseType:'json',//default // xsrfCookieName: 'XSRF-TOKEN',//default xsrfHeaderName:'X-XSRF-TOKEN',//default //`onUploadProgress`上传进度事件 onUploadProgress:function(progressEvent)&#123; //下载进度的事件onDownloadProgress:function(progressEvent)&#123;&#125; &#125;, //相应内容的最大值 maxContentLength:2000, //`validateStatus`定义了是否根据http相应状态码，来resolve或者reject promise //如果`validateStatus`返回true(或者设置为`null`或者`undefined`),那么promise的状态将会是resolved,否则其状态就是rejected validateStatus:function(status)&#123; return status &gt;= 200 &amp;&amp; status &lt;300;//default &#125;, //`maxRedirects`定义了在nodejs中重定向的最大数量 maxRedirects: 5,//default //`httpAgent/httpsAgent`定义了当发送http/https请求要用到的自定义代理 //keeyAlive在选项中没有被默认激活 httpAgent: new http.Agent(&#123;keeyAlive:true&#125;), httpsAgent: new https.Agent(&#123;keeyAlive:true&#125;), //proxy定义了主机名字和端口号， //`auth`表明http基本认证应该与proxy代理链接，并提供证书 //这将会设置一个`Proxy-Authorization` header,并且会覆盖掉已经存在的`Proxy-Authorization` header proxy: &#123; host:'127.0.0.1', port: 9000, auth: &#123; username:'skda', password:'radsd' &#125; &#125;, //`cancelToken`定义了一个用于取消请求的cancel token //详见cancelation部分 cancelToken: new cancelToken(function(cancel)&#123; &#125;)&#125; 五、请求返回的内容1234567891011&#123; data:&#123;&#125;, status:200, //从服务器返回的http状态文本 statusText:'OK', //响应头信息 headers: &#123;&#125;, //`config`是在请求的时候的一些配置信息 config: &#123;&#125;&#125; 你可以这样来获取响应信息12345678axios.get('/user/12345')then(function(res)&#123; console.log(res.data); console.log(res.status); console.log(res.statusText); console.log(res.headers); console.log(res.config);&#125;) 六、默认配置你可以设置默认配置，对所有请求都有效 1、 全局默认配置 123axios.defaults.baseURL = 'http://api.exmple.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['content-Type'] = 'appliction/x-www-form-urlencoded'; 2、 自定义的实例默认设置 1234567//当创建实例的时候配置默认配置var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);//当实例创建时候修改配置instance.defaults.headers.common[\"Authorization\"] = AUTH_TOKEN; 3、 配置中的有优先级 config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。12345678910//创建一个实例的时候会使用libray目录中的默认配置//在这里timeout配置的值为0，来自于libray的默认值var instance = axios.create();//回覆盖掉library的默认值//现在所有的请求都要等2.5S之后才会发出instance.defaults.timeout = 2500;//这里的timeout回覆盖之前的2.5S变成5sinstance.get('/longRequest',&#123; timeout: 5000&#125;); 七、拦截器 1、你可以在请求、响应在到达then/catch之前拦截他们 12345678910111213141516//添加一个请求拦截器axios.interceptors.request.use(function(config)&#123; //在请求发出之前进行一些操作 return config;&#125;,function(err)&#123; //Do something with request error return Promise.reject(error);&#125;);//添加一个响应拦截器axios.interceptors.response.use(function(res)&#123; //在这里对返回的数据进行处理 return res;&#125;,function(err)&#123; //Do something with response error return Promise.reject(error);&#125;) 2、取消拦截器 12var myInterceptor = axios.interceptor.request.use(function()&#123;/*....*/&#125;);axios.interceptors.request.eject(myInterceptor); 3、 给自定义的axios实例添加拦截器 12var instance = axios.create();instance.interceptors.request.use(function()&#123;&#125;) 八、错误处理12345678910111213axios.get('/user/12345') .catch(function(error)&#123; if(error.response)&#123; //请求已经发出，但是服务器响应返回的状态吗不在2xx的范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.header); &#125;else &#123; //一些错误是在设置请求的时候触发 console.log('Error',error.message); &#125; console.log(error.config); &#125;); 九、取消 你可以通过一个cancel token来取消一个请求 你可以通过CancelToken.source工厂函数来创建一个cancel token 123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345',&#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if(axios.isCancel(thrown))&#123; console.log('Request canceled',thrown.message); &#125;else &#123; //handle error &#125;&#125;);//取消请求（信息的参数可以设置的）source.cance(\"操作被用户取消\"); 你可以给cancelToken构造函数传递一个executor function来创建一个cancel token: 12345678910var cancelToken = axios.CancelToken;var cance;axios.get('/user/12345',&#123;cancelToken: new CancelToken(function(c)&#123; //这个executor函数接受一个cancel function作为参数 cancel = c;&#125;)&#125;)//取消请求cancel();","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue之vuex","date":"2017-07-26T06:12:24.000Z","path":"2017/07/26/vue之vuex/","text":"前言在vue里，组件之间的作用域是独立的，父组件跟子组件之间的通讯可以通过prop属性来传参，但是在兄弟组件之间通讯就比较麻烦了。比如A组件要告诉一件事给B组件，那么A就要先告诉他们的爸组件，然后爸组件再告诉B。当组件比较多，要互相通讯的事情很多的话，爸组件要管他们那么多事，很累的。vuex正是为了解决这个问题，让多个子组件之间可以方便的通讯。待办事项中的一个事件，它可能拥有几个状态，未完成、已完成、已取消或被删除等。这个事件需要在这多种状态之间切换，那么使用vuex来管理也是非常方便的。 来看一下vuex怎么完成状态管理的： 以上的图分为以下几步： 1.所有的组件都是调用actions 2.分发mutation去修改state 3.然后state又通过getter更新到各个组件中 模块化1234567891011121314|-store/ // 存放vuex代码| |-eventModule // 事件模块| | |-actions.js| | |-getters.js| | |-index.js| | |-mutations.js| | |-state.js| |-themeModule // 主题颜色模块| | |-actions.js| | |-getters.js| | |-index.js| | |-mutations.js| | |-state.js| |-index.js // vuex的核心，创建一个store 可以看到，每个模块拥有自己的state、mutation、action、getter，这样子我们就可以把我们的项目根据功能划分为多个模块去使用vuex了，而且后期维护也不会一脸懵逼。 状态管理接下来，我们来看看vuex完成状态管理的一个流程。举个栗子：一个待办事项，勾选之后，会在未完成列表里移除，并在已完成的列表里出现。这个过程，是这个待办事项的状态发生了改变。勾选的时候，是执行了一个方法，那我们就先写这个方法。在 event_list.vue 文件里新建一个moveToDone方法。12345methods: &#123; moveToDone(id)&#123; //移至已完成 this.$store.dispatch('eventdone', id); &#125;&#125; 在 moveToDone 方法中通过 store.dispatch 方法触发 action, 接下来我们在 eventModule/actions.js 中来注册这个 action, 接受一个 id 的参数。12345export default &#123; eventdone = (&#123; commit &#125;, param) =&gt;&#123; commit('EVENTDONE',&#123;id: param&#125;); &#125;&#125; action 通过调用 store.commit 提交载荷(也就是{id: param}这个对象)到名为’EVENTDONE’的 mutation，那我们再来注册这个 mutation123456789101112131415export default &#123; EVENTDONE(states,obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 2; states.event[i].time = getDate(); var item = states.event[i]; states.event.splice(i, 1); // 把该事件在数组中删除 break; &#125; &#125; states.event.unshift(item); // 把该事件存到数组的第一个元素 local.set(states); // 将整个状态存到本地 &#125;&#125; 通过 mutation 去修改 state, state里我们存放了一个 event 属性123export default &#123; event: []&#125;; 在组件中要获得这个 state 里的 event, 那就需要写个getters123456789export default &#123; getDone(states)&#123; return states.event.filter(function (d) &#123; if (d.type === 2) &#123; // type == 2表示已完成 return d; // 返回已完成的事件 &#125; &#125;); &#125;&#125;; 然后每个module里都有一个index.js文件，把自己的state、mutation、action、getters都集合起来，就是一个module123456789101112import * as func from '../function';import actions from './actions.js';import mutations from './mutations.js';import state from './state.js';import getters from './getters.js';export default &#123; state, getters, actions, mutations&#125; 在 store/index.js 里创建一个 store 对象来存放这个module123456789import Vue from 'vue';import Vuex from 'vuex';import event from './eventModule';Vue.use(Vuex);export default new Vuex.Store(&#123; modules: &#123; event &#125;&#125;); 最后在 event_list.vue 组件上，我们通过计算属性 computed 来获取到这个从未完成的状态改变到已完成的状态，我们要用到 store 这个对象里的getters12345computed: &#123; getDone()&#123; return this.$store.getters.getDone; &#125;&#125; 源码地址","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"es6之Class","date":"2017-07-24T14:10:24.000Z","path":"2017/07/24/es6之Class/","text":"Class 1.在之前的JS面向对象编程中，如果定义一个构造函数，一般来说是这样：1234567function Person( name , age ) &#123; this.name = name; this.age = age;&#125;Person.prototype.say = function()&#123; return 'My name is ' + this.name + ', I am ' + this.age + ' years old';&#125; 这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，对于一些新学习JS的程序员来说不太容易理解，ES6 引入了 Class（类）这个概念，提供了更接近传统语言的写法，上述代码用 ES6 实现就是：12345678910class Person &#123; constructor( name , age ) &#123; this.name = name; this.age = age; &#125; say() &#123; return return 'My name is ' + this.name + ', I am ' + this.age + ' years old'; &#125;&#125; 上述代码中的constructor方法，这就是构造方法，而this关键字则代表实例对象 2.constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，会被默认添加一个空的constructor方法； 1234567class Person &#123;&#125;// 等同于class Person &#123; constructor() &#123;&#125;&#125; 3.constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象，但实际开发中不建议这么做； 1234567class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo //false 此时constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例，因此会返回 false； 4.使用new运算符用于生成类的实例对象，如果忘记加上new，像函数那样调用Class，将会报错； 123456789class Person &#123; // ...&#125;// 报错var person = Person();// 正确var person = new Person(); 5.实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上），并且，类的所有实例共享一个原型对象12345678910111213141516171819class Person &#123; //自身属性 constructor( name , age ) &#123; this.name = name; this.age = age; &#125; //原型对象的属性 say() &#123; return 'My name is ' + this.name + ', I am ' + this.age + ' years old'; &#125;&#125;var person = new Person( 'Jack' , 23);person.hasOwnProperty('name') // trueperson.hasOwnProperty('age') // trueperson.hasOwnProperty('say') // falseperson.__proto__.hasOwnProperty('say') // true 上述代码中，name 和 age 实例对象person自身的属性（因为定义在this变量上） ，所以hasOwnProperty方法返回true，而say是原型对象的属性（因为定义在Person类上），所以hasOwnProperty方法返回false； 6.与函数一样，可以使用表达式的形式定义一个类，即12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125; 值得注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，用来指代当前类；如果类的内部没用到的话，可以省略Me，写成下面的形式：12345const MyClass = class &#123; getClassName() &#123; return Me.name; &#125;&#125; 7.采用 Class 表达式，可以写出立即执行的 Class。 123456789101112let Person = new class &#123; constructor(name , age ) &#123; this.name = name; this.age = age; &#125; say() &#123; return 'My name is ' + this.name + ', I am ' + this.age + ' years old'; &#125;&#125;('Jack' , 23 );Person.say(); // 'My name is Jack, I am 23 years old' 8.ES6中类不存在变量提升，不会把类的声明提升到代码头部，即如果类使用在前，定义在后，这样会报错； 12new Person(); //Uncaught ReferenceError : Person is not definedclass Person&#123;&#125; 9.跟ES5一样，ES6的类定义中，也不支持私有属性和私有方法，只能通过变通的方法模拟实现（命名上加下划线等）； 10.可以在一个类的方法前，加上static关键字，声明其为‘静态方法’，这样就表示该方法不会被实例继承，而是直接通过类来调用； 12345678910class Foo &#123; static classMethod() &#123; return 'Hello World'; &#125;&#125;Foo.classMethod() // 'Hello World'var foo = new Foo();foo.classMethod() // TypeError: foo.classMethod is not a function 11.父类的静态方法，可以被子类继承，也可以从super对象上调用。 1234567891011121314151617181920class Parent &#123; static classMethod() &#123; return 'Hello World'; &#125;&#125;//子类继承class Child extends Parent &#123;&#125;Child.classMethod() // 'Hello World'//super对象上调用class Child extends Parent &#123; static classMethod() &#123; return super.classMethod(); &#125;&#125;Child.classMethod() // 'Hello World' 12.静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性，并且目前只能有以下方式定义： 12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 13.Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多； 1234567class Parent &#123; //&#125;//子类继承class Child extends Parent &#123;&#125; 上面代码定义了一个Child类，该类通过extends关键字，继承了Parent类的所有属性和方法； 14.子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象； 123456789101112131415class Parent( name , age ) &#123; //&#125;//子类继承class Child extends Parent &#123; constructor( name , age , hobby ) &#123; super( name , age ); // 调用父类的constructor( name , age ) this.hobby = hobby; &#125; say()&#123; return 'My name is ' + this.name + ', I am ' + this.age + ' years old , I like ' + this.hobby; &#125;&#125; 15.super关键字，既可以当作函数使用，也可以当作对象使用： 作为函数调用时，代表父类的构造函数，并且只能用在子类的构造函数之中，用在其他地方就会报错； 123456class A &#123;&#125;class B extends A &#123; m() &#123; super(); // 报错 &#125;&#125; 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类 123456789101112class A &#123; p() &#123; return 2; &#125; &#125; class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125; &#125; let b = new B(); 需要注意的是，super指向的是父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的1234567891011121314class A &#123; constructor() &#123; this.p = 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p; &#125;&#125;let b = new B();b.m // undefined 16.ES6 规定，通过super调用父类的方法时，super会绑定子类的 this 123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print(); &#125;&#125;let b = new B();b.m() // 2 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 17.由于绑定子类的this，因此如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性；123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; &#125; print()&#123; console.log(super.x); // undefined console.log(this.x); // 3 &#125;&#125;let b = new B();b.print(); 上面代码中，super.x 赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，而A的原型上没有x属性，所以返回undefined。 18.如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。123456789101112131415161718192021222324class Parent &#123; static myMethod(msg) &#123; console.log('static'); &#125; myMethod(msg) &#123; console.log('instance'); &#125;&#125;class Child extends Parent &#123; static myMethod() &#123; super.myMethod(); &#125; myMethod(msg) &#123; super.myMethod(); &#125;&#125;Child.myMethod(); // static var child = new Child();child.myMethod(); // instance 上述代码表明super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 19.Class 作为构造函数的语法糖，同时有prototype属性和 proto属性，因此同时存在两条继承链 子类的proto属性，表示构造函数的继承，总是指向父类。 子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性123456class A &#123;&#125;class B extends A &#123;&#125;B._proto_ === A // trueB.prototype._proto_ === A.prototype // true 20.extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构，下面就是定义了一个带版本功能的数组例子。 1234567891011121314151617181920212223242526272829class VersionedArray extends Array &#123; constructor() &#123; super(); this.history = [[]]; &#125; commit() &#123; this.history.push(this.slice()); &#125; revert() &#123; this.splice(0, this.length, ...this.history[this.history.length - 1]); &#125;&#125;var x = new VersionedArray();x.push(1);x.push(2);x // [1, 2]x.history // [[]]x.commit();x.history // [[], [1, 2]]x.push(3);x // [1, 2, 3]x.history // [[], [1, 2]]x.revert();x // [1, 2]","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"vue组件data为什么是函数？","date":"2017-07-20T09:10:24.000Z","path":"2017/07/20/vue组件data为什么是函数？/","text":"在创建或注册模板的时候，传入一个data属性作为用来绑定的数据。但是在组件中，data必须是一个函数，而不能直接把一个对象赋值给它。123456Vue.component('my-component', &#123; template: '&lt;div&gt;OK&lt;/div&gt;', data() &#123; return &#123;&#125; // 返回一个唯一的对象，不要和其他组件共用一个对象进行返回 &#125;,&#125;) 你在前面看到，在new Vue()的时候，是可以给data直接赋值为一个对象的。这是怎么回事，为什么到了组件这里就不行了。 你要理解，上面这个操作是一个简易操作，实际上，它首先需要创建一个组件构造器，然后注册组件。注册组件的本质其实就是建立一个组件构造器的引用。使用组件才是真正创建一个组件实例。所以，注册组件其实并不产生新的组件类，但会产生一个可以用来实例化的新方式。 理解这点之后，再理解js的原型链： 1234567891011121314var MyComponent = function() &#123;&#125;MyComponent.prototype.data = &#123; a: 1, b: 2,&#125;// 上面是一个虚拟的组件构造器，真实的组件构造器方法很多var component1 = new MyComponent()var component2 = new MyComponent()// 上面实例化出来两个组件实例，也就是通过&lt;my-component&gt;调用，创建的两个实例component1.data.a === component2.data.a // truecomponent1.data.b = 5component2.data.b // 5 可以看到上面代码中最后三句，这就比较坑爹了，如果两个实例同时引用一个对象，那么当你修改其中一个属性的时候，另外一个实例也会跟着改。这怎么可以，两个实例应该有自己各自的域才对。所以，需要通过下面方法来进行处理： 123456789var MyComponent = function() &#123; this.data = this.data()&#125;MyComponent.prototype.data = function() &#123; return &#123; a: 1, b: 2, &#125;&#125; 这样每一个实例的data属性都是独立的，不会相互影响了。所以，你现在知道为什么vue组件的data必须是函数了吧。这都是因为js本身的特性带来的，跟vue本身设计无关。其实vue不应该把这个方法名取为data()，应该叫setData或其他更容易立即的方法名。","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"JavaScript之闭包详解篇2","date":"2017-07-12T12:42:56.000Z","path":"2017/07/12/JavaScript之闭包详解篇2/","text":"定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子： 1234567var a = 1;function foo() &#123; console.log(a);&#125;foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 接下来就来讲讲实践上的闭包。 分析让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动：1234567891011var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。另一个与这段代码相似的例子，在JavaScript深入之执行上下文中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……) 然而 JavaScript 却是可以的！ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO],&#125; 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 所以，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 必刷题接下来，看这道刷题必刷，面试必考的闭包题： 1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为：123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为：123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看： 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的AO为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。 data[1] 和 data[2] 是一样的道理。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"图解 TCP 三次握手与四次分手","date":"2017-07-12T06:12:24.000Z","path":"2017/07/12/图解TCP三次握手与四次分手/","text":"引言TCP三次握手和四次挥手不管是在开发还是面试中都是一个非常重要的知识点，它是我们优化web程序性能的基础。但是大部分教材都对这部分解释的比较抽象，本文我们就利用wireshark来抓包以真正体会整个流程的细节。 为什么要进行三次握手我们来看一下为什么需要进行三次握手，两次握手难道不行么？这里我们用一个生活中的具体例子来解释就很好理解了。我们可以将三次握手中的客户端和服务器之间的握手过程比喻成A和B通信的过程： 在第一次通信过程中，A向B发送信息之后，B收到信息后可以确认自己的收信能力和A的发信能力没有问题。 在第二次通信中，B向A发送信息之后，A可以确认自己的发信能力和B的收信能力没有问题，但是B不知道自己的发信能力到底如何，所以就需要第三次通信。 在第三次通信中，A向B发送信息之后，B就可以确认自己的收信能力没有问题。 三次握手根据下面这幅图我们来看一下TCP三次握手。p.s: 每个箭头代表一次握手。 第一次握手client发送一个SYN(J)包给server，然后等待server的ACK回复，进入SYN-SENT状态。p.s: SYN为synchronize的缩写，ACK为acknowledgment的缩写。 第二次握手server接收到SYN(seq=J)包后就返回一个ACK(J+1)包以及一个自己的SYN(K)包，然后等待client的ACK回复，server进入SYN-RECIVED状态。 第三次握手client接收到server发回的ACK(J+1)包后，进入ESTABLISHED状态。然后根据server发来的SYN(K)包，返回给等待中的server一个ACK(K+1)包。等待中的server收到ACK回复，也把自己的状态设置为ESTABLISHED。到此TCP三次握手完成，client与server可以正常进行通信了。 四次挥手以下面这张图为例，我们来分析一下TCP四次挥手的过程。 第一次挥手client发送一个FIN(M)包，此时client进入FIN-WAIT-1状态，这表明client已经没有数据要发送了。 第二次挥手server收到了client发来的FIN(M)包后，向client发回一个ACK(M+1)包，此时server进入CLOSE-WAIT状态，client进入FIN-WAIT-2状态。 第三次挥手server向client发送FIN(N)包，请求关闭连接，同时server进入LAST-ACK状态。 第四次挥手client收到server发送的FIN(N)包，进入TIME-WAIT状态。向server发送ACK(N+1)包，server收到client的ACK(N+1)包以后，进入CLOSE状态；client等待一段时间还没有得到回复后判断server已正式关闭，进入CLOSE状态。","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"extract-text-webpack-plugin单独打包CSS","date":"2017-07-11T05:12:24.000Z","path":"2017/07/11/extract-text-webpack-plugin 的使用及安装/","text":"extract-text-webpack-plugin该插件的主要是为了抽离css样式,防止将样式打包在js中引起页面样式加载错乱的现象;首先我先来介绍下这个插件的安装方法:1npm install extract-text-webpack-plugin --save-dev 首先进入项目的根目录,然后执行以上命令进行插件的安装,插件安装完成后,接下来我们要做的就是在webpack.config.js中引入该插件123456789101112131415161718const ExtractTextPlugin = require(\"extract-text-webpack-plugin\");module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(\"styles.css\"), ]&#125; 该插件有三个参数意义分别如下:123use:指需要什么样的loader去编译文件,这里由于源文件是.css所以选择css-loaderfallback:编译后用什么loader来提取css文件publicfile:用来覆盖项目路径,生成该css文件的文件路径","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack独立打包和缓存处理","date":"2017-07-10T03:12:24.000Z","path":"2017/07/10/webpack独立打包和缓存处理/","text":"独立打包123456789101112131415161718var webpack = require('webpack');var path = require('path'); module.exports = &#123; entry: &#123; main: './app/index.js', vendor: ['jquery'] &#125;, output: &#123; filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;, plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor' &#125;), ]&#125; 上方我们将原本的单入口文件改成了多入口文件，并加入了vendor属性。vendor属性用于配置打包第三方类库，写入数组的类库名将统一打包到一个文件里。同时我们将输出的filename用[name]变量来自动生成文件名，最后我们添加了一个CommonsChunkPlugin的插件，用于提取vendor。配置完成后我们运行webpack命令：12345678910Hash: ee1daf95c1986768927aVersion: webpack 2.3.2Time: 573ms Asset Size Chunks Chunk Names main.js 340 bytes 0 [emitted] mainvendor.js 274 kB 1 [emitted] [big] vendor [0] ./~/jquery/dist/jquery.js 267 kB &#123;1&#125; [built] [1] ./app/hello.js 53 bytes &#123;0&#125; [built] [2] ./app/index.js 114 bytes &#123;0&#125; [built] [3] multi jquery 28 bytes &#123;1&#125; [built] 最终发现我们成功将jQuery打包到了vendor.js中，实现了独立打包，但是问题又来了：每次打包后生成的文件名都是一样的，浏览器可能缓存上一次的结果而无法加载最新数据。 添加hash为了解决上述问题，我们需要为打包后的文件名添加hash值，这样每次修改后打包的文件hash值将改变，修改配置文件如下：12345678module.exports = &#123; ... output: &#123; filename: '[name].[chunkHash:5].js', path: path.resolve(__dirname, 'dist') &#125;, ...&#125; 上方我们在输出文件名中增加了[chunkHash:5]变量，表示打包后的文件中加入保留5位的hash值。我们再次运行打包命令： 12345678910Hash: c7d1295f2f9a27c412d2Version: webpack 2.3.2Time: 603ms Asset Size Chunks Chunk Names main.2a7ad.js 337 bytes 0 [emitted] mainvendor.49eb4.js 274 kB 1 [emitted] [big] vendor [0] ./~/jquery/dist/jquery.js 267 kB &#123;1&#125; [built] [1] ./app/hello.js 50 bytes &#123;0&#125; [built] [2] ./app/index.js 114 bytes &#123;0&#125; [built] [3] multi jquery 28 bytes &#123;1&#125; [built] 上方我们发现打包后的文件成功加上了hash值，这样每次修改文件后hash值也会跟着变，就不怕浏览器缓存了，但是当我们尝试去修改一个js文件后再次打包，问题又来了：vendor.js的hash值也变了，我们并没有修改jQuery的源码。 修改vendor配置上述问题产生的原因是因为CommonsChunkPlugin插件是用于提取公共代码的，上方我们只是提取了vendor作为公共代码。为了继续解决上述问题，其实方法很简单，我们需要修改CommonsChunkPlugin的配置，如下：123456789module.exports = &#123; ... plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123; names: ['vendor', 'manifest'] &#125;), ] ...&#125; 如此我们修改一下hello.js中的代码，发现vendor的hash值并未改变，并且多了一个manifest.js的小文件。manifest.js为webpack的启动文件代码，它会直接影响到hash值，用mainfest单独抽出来了，这样vendor的hash就不会变了。 生成index.html通过以上对webpack配置文件的一系列修改，我们成功实现了webpack的独立打包与缓存处理，但是还差最后一步。因为我们最终打包后生成的文件名中带有hash值，每次都是会变的，所以我们不能像目前这样在index.html中写死路径。1234567...&lt;body&gt; &lt;script src=\"./dist/main.js\"&gt;&lt;/script&gt; &lt;script src=\"./dist/vendor.js\"&gt;&lt;/script&gt; &lt;script src=\"./dist/manifest.js\"&gt;&lt;/script&gt;&lt;/body&gt;... 以上写法是不对的，因为缺少了可变的hash值，因此我们希望每次打包后index.html中的路径也会自动加上hash值，解决方法如下：1234567891011121314var HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; ... plugins:[ ... new HtmlWebpackPlugin(&#123; title: 'demo', template: 'index.html' // 模板路径 &#125;), ... ] ...&#125; 上方我们引入了html-webpack-plugin这一个插件，该插件可以帮助我们根据模板生成html文件。在plugins设置中，title配置了生成html中的title部分，template为模板html的路径地址。我们需要下载html-webpack-plugin：1npm install html-webpack-plugin --save-dev 安装和配置完毕后，运行打包命令：webpack123456789101112Hash: 0c4b91e206579b31544dVersion: webpack 2.3.2Time: 856ms Asset Size Chunks Chunk Names vendor.e1868.js 268 kB 0 [emitted] [big] vendor main.44412.js 337 bytes 1 [emitted] mainmanifest.ed186.js 5.81 kB 2 [emitted] manifest index.html 292 bytes [emitted] [0] ./~/jquery/dist/jquery.js 267 kB &#123;0&#125; [built] [1] ./app/hello.js 50 bytes &#123;1&#125; [built] [2] ./app/index.js 114 bytes &#123;1&#125; [built] [3] multi jquery 28 bytes &#123;0&#125; [built] 我们发现在dist目录下生成了一个index.html文件，打开该文件后代码如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\" src=\"manifest.ed186.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"vendor.e1868.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"main.44412.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 至此我们实现了每次打包后index.html中的路径也会自动加上hash值的功能，因此dist目录下的index.html即为以后的首页文件，最后我们在浏览器中打开该文件成功显示：","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack多页面项目构建","date":"2017-07-10T02:12:24.000Z","path":"2017/07/10/webpack多页面项目构建/","text":"使用 webpack 已经将近一年了，期间用它构建过4、5个项目，踩过一些坑，现在用自己的理解记录下来。 我现在教你如何一步一步搭建 webpack 开发的多页面项目。本文项目地址在 https://github.com/blockmood/generate-pages-tutorial 具体看github吧 123456789101112131415161718192021var path = require('path');var ROOT = path.resolve(__dirname)module.exports = &#123; entry:&#123; 'page1/main':'./src/page1/main', 'page2/main':'./src/page2/main' &#125;, output:&#123; filename:'[name].js', path:ROOT + '/dist/' &#125;, module: &#123; rules:[ &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" &#125; ] &#125;&#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack编译es6之babel配置","date":"2017-07-07T05:12:24.000Z","path":"2017/07/07/webpack编译es6 之babel/","text":"安插件1npm install --save-dev babel-core babel-loader babel-preset-es2015 .banelrc 文件配置123&#123; \"presets\": [\"es2015\"]&#125; webpack 配置12345&#123; test: /\\.js$/, loader: 'babel-loader', query: &#123;presets: ['es2015']&#125;&#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"gulp配置","date":"2017-07-06T00:12:24.000Z","path":"2017/07/06/gulp配置/","text":"package.json1234567891011121314151617181920212223242526&#123; \"name\": \"gulp\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"iceStone &lt;ice@wedn.net&gt; (http://wedn.net/)\", \"license\": \"ISC\", \"devDependencies\": &#123; \"browser-sync\": \"^2.11.1\", \"del\": \"^2.2.0\", \"gulp\": \"^3.9.0\", \"gulp-autoprefixer\": \"^3.1.0\", \"gulp-base64\": \"^0.1.3\", \"gulp-concat\": \"^2.6.0\", \"gulp-cssnano\": \"^2.1.0\", \"gulp-htmlmin\": \"^1.3.0\", \"gulp-imagemin\": \"^3.3.0\", \"gulp-less\": \"^3.0.5\", \"gulp-rev\": \"^7.1.2\", \"gulp-rev-collector\": \"^1.2.2\", \"gulp-uglify\": \"^3.0.0\" &#125;&#125; gulpfile.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var gulp = require('gulp');var less = require('gulp-less');var cssnano = require('gulp-cssnano');var base64 = require('gulp-base64');var imagemin = require('gulp-imagemin');var concat = require('gulp-concat');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var browserSync = require('browser-sync');var rev = require('gulp-rev');var revCollector = require('gulp-rev-collector');gulp.task('css',['images'],function() &#123; gulp.src(['src/css/*.less', '!src/css/_*.less']) .pipe(less()) .pipe(base64(&#123; extensions: ['png', /\\.jpg#datauri$/i], exclude: [/\\.server\\.(com|net)\\/dynamic\\//, '--live.jpg'], maxImageSize: 800*1024, debug: true &#125;)) .pipe(concat('style.min.css')) .pipe(cssnano()) .pipe(gulp.dest('dist/css')) .pipe(browserSync.reload(&#123; stream: true &#125;));&#125;);gulp.task('images',function()&#123; gulp.src('./src/images/*') .pipe(gulp.dest('dist/images'))&#125;);gulp.task('js', function() &#123; gulp.src('src/js/*.js') .pipe(concat('all.js')) .pipe(uglify()) .pipe(gulp.dest('dist/js')) .pipe(browserSync.reload(&#123; stream: true &#125;));&#125;);gulp.task('html', function() &#123; gulp.src('src/*.html') .pipe(htmlmin(&#123; collapseWhitespace: true, removeComments: true &#125;)) .pipe(gulp.dest('dist')) .pipe(browserSync.reload(&#123; stream: true &#125;));&#125;);gulp.task('md5',function()&#123; gulp.src('dist/css/*.css') .pipe(rev()) .pipe(gulp.dest('dist/css/')) .pipe(rev.manifest()) .pipe(gulp.dest('dist/config'))&#125;)gulp.task('top',function()&#123; gulp.src(['./dist/config/*.json', './dist/*.html']) .pipe(revCollector()) .pipe(gulp.dest('./dist/'))&#125;)gulp.task('server', function() &#123; browserSync(&#123; server: &#123; baseDir: ['dist'] &#125;, &#125;, function(err, bs) &#123; console.log(bs.options.getIn([\"urls\", \"local\"])); &#125;); gulp.watch('src/*.html',['html']); gulp.watch('src/css/*.less',['css']); gulp.watch('src/js/*.js',['js']);&#125;);","tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"gulp + webpack 构建多页面前端项目","date":"2017-07-05T11:12:24.000Z","path":"2017/07/05/gulp + webpack 构建多页面前端项目/","text":"之前在使用gulp和webpack对项目进行构建的时候遇到了一些问题，最终算是搭建了一套比较完整的解决方案，接下来这篇文章以一个实际项目为例子，讲解多页面项目中如何利用gulp和webpack进行工程化构建。本文是自己的实践经验，所以有些解决方案并不是最优的，仍在探索优化中。所以有什么错误疏漏请随时指出。 前言现在为什么又整了一个webpack进来呢？ 我们知道webpack近来都比较火，那他火的原因是什么，有什么特别屌的功能吗？带着这些疑问，继续看下去。 在使用gulp进行项目构建的时候，我们一开始的策略是将所有js打包为一个文件，所有css打包为一个文件。然后每个页面都将只加载一个js和一个css,也就是我们通常所说的 ==all in one== 打包模式。这样做的目的就是减少http请求。这个方案对于简单的前端项目来说的是一个万金油。因为通常页面依赖的js,css并不会太大，通过压缩和gzip等方法更加减小了文件的体积。在项目最开始的一段时间内（几个月甚至更长），一个前端团队都能通过这种办法达到以不变应万变的效果。 然而，作为一个有追求（爱折腾）的前端，难道就满足于此吗？ 妈妈说我不仅要请求合并，还要按需加载，我要模块化开发，还要自动监听文件更新，支持图片自动合并…. 等等！你真的需要这些功能吗？是项目真的遇到了性能问题？不然你整这些干嘛？ 对于pc端应用来说，性能往往不是最突出的问题，因为pc端的网速，浏览器性能都有比较好，所以很长一段时间我们要考虑的是开发效率的问题而不是性能问题，得在前端框架的选型上下功夫。至于加载文件的大小或文件个数，都难以形成性能瓶颈。 对于wap端来说，限制于手机的慢网速（仍然有很多用不上4g，wifi的人），对网站的性能要求就比较苛刻了，这时候就不仅仅要考虑开发效率的问题了。（移动网络的性能问题可参考《web性能权威指南》） 这点我有不一样的看法。如果我们在项目搭建的时候就能考虑得多一点，把基本能做的先做了。所花的成本绝对比以后去重构代码的成本要低很多，而且我们能够同时保证开发效率和网站性能，何乐而不为呢。 问题竟然要做，那要做到什么程度呢，往往“度”是最难把握的东西。 以前在做wap网站的时候，遇到的最大的问题按需加载和请求合并的权衡。通过纯前端的方法不能同时满足请求合并和按需加载，这里面的原理和难点已经有大牛讲得很清楚了 前端工程与模块化框架 实现的方法归纳起来主要有以下步骤： 通过工具分析出前端静态文件依赖表 页面通过模块化工具加载入口文件，并将所依赖的所有文件合并为combo请求。 后端返回combo文件，浏览器将模块缓存起来，跳页面的时候执行步骤2，只请求没有缓存过的文件。 如此通过依赖分析和后端combo实现了按需加载和请求合并。 这种实现方式的缺陷就是需要后端的支持，如果前端团队本身不是自己实现的后端路由层，需要后端同学加以配合，就需要更多沟通成本。 在没有后端支持的情况下，很难实现按需加载和请求合并。 针对这个问题webpack有没有什么解决方案？而webpack和gulp又是怎么协作的呢？请看下去。 webpack的使用webpack可以说是一个大而全的前端构建工具。它实现了模块化开发和静态文件处理两大问题。 以往我们要在项目中支持模块化开发，需要引入requirejs，seajs等模块加载框架。而webpack天生支持AMD，CommonJS, ES6 module等模块规范。不用思考加载器的选型，可以直接像写nodejs一样写模块。而webpack这种万物皆模块的思想好像就是为React而生的，在React组件中可以直接引入css或图片，而做到这一切只需要一个require语句和loader的配置。 webpack的功能之多和繁杂的配置项会让初学者感到眼花缭乱，网上的很多资料也是只介绍功能不教人实用技巧。这里有一篇文章就讲解了webpack开发的workflow, 虽然该教程是基于React的，但是比较完整地讲了webpack的开发流程。下面我也用一个实例讲解使用中遇到的问题和解决方案。 我们的项目是一个多页面项目，即每个页面为一个html，访问不同的页面需要跳转链接。项目目录结构大概是这样的，app放html文件，css为样式文件，images存放图片，js下有不同的文件夹，里面的子文件夹为一些核心文件和一些库文件，ui组件。js的根目录为页面入口文件。 1234567891011121314151617├── app│ ├── header.inc│ ├── help-charge.inc│ ├── index.html│ ├── news-detail.html│ └── news-list.html├── css│ ├── icon.less│ └── slider.css├── images└── js ├── core ├── lib ├── ui ├── news-detail.js ├── news-list.js └── main.js 该项目中我们只用webpack处理js文件的合并压缩。其他任务交给gulp。关于多页面项目和单页面项目中js处理的差异请看这里。 配置文件如下：12345678910111213141516171819202122232425262728293031323334353637383940module.exports = &#123; devtool: \"source-map\", //生成sourcemap,便于开发调试 entry: getEntry(), //获取项目入口js文件 output: &#123; path: path.join(__dirname, \"dist/js/\"), //文件输出目录 publicPath: \"dist/js/\", //用于配置文件发布路径，如CDN或本地服务器 filename: \"[name].js\", //根据入口文件输出的对应多个文件名 &#125;, module: &#123; //各种加载器，即让各种文件格式可用require引用 loaders: [ // &#123; test: /\\.css$/, loader: \"style-loader!css-loader\"&#125;, // &#123; test: /\\.less$/, loader: \"style-loader!csss-loader!less-loader\"&#125; ] &#125;, resolve: &#123; //配置别名，在项目中可缩减引用路径 alias: &#123; jquery: srcDir + \"/js/lib/jquery.min.js\", core: srcDir + \"/js/core\", ui: srcDir + \"/js/ui\" &#125; &#125;, plugins: [ //提供全局的变量，在模块中使用无需用require引入 new webpack.ProvidePlugin(&#123; jQuery: \"jquery\", $: \"jquery\", // nie: \"nie\" &#125;), //将公共代码抽离出来合并为一个文件 new CommonsChunkPlugin('common.js'), //js文件的压缩 new uglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;; 配置项参考文档 打包思路：该配置方案的思路是每个页面一个入口文件，文件中可以通过require引入其他模块，而这些模块webpack会自动跟入口文件合并为一个文件。通过getEntry获取入口文件： 123456789101112function getEntry() &#123; var jsPath = path.resolve(srcDir, 'js'); var dirs = fs.readdirSync(jsPath); var matchs = [], files = &#123;&#125;; dirs.forEach(function (item) &#123; matchs = item.match(/(.+)\\.js$/); if (matchs) &#123; files[matchs[1]] = path.resolve(srcDir, 'js', item); &#125; &#125;); return files;&#125; 该方法将生成文件名到文件绝对路径的map， 比如 123entry：&#123; news-detail: /../Document/project/.../news-detail.js&#125; 然后output就会在output.path路径下生成[name].js，即news-detail.js,文件名保持相同。 module 的作用是添加loaders, 那loaders有什么作用呢？如果我们想要在js文件中通过require引入模块，比如css或image，那么就需要在这里配置加载器，这一点对于React来说相当方便，因为可以在组件中使用模块化CSS。而一般的项目中可以不用到这个加载器。 resolve 中的alias可以用于定义别名，用过seajs等模块工具的都知道alias的作用，比如我们在这里定义了ui这个别名，那么在模块中想引用ui目录下的文件，就可以直接这样写 1require('ui/dialog.js'); 不用加上前面的更长的文件路径。 plugin 用于引入一些插件，常见的有 这些我们这里使用了CommonsChunkPlugin用于生成公用代码，不只可以生成一个，还能根据不同页面的文件关系，自由生成多个，例如： 1234567891011121314151617181920212223var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; p1: \"./page1\", p2: \"./page2\", p3: \"./page3\", ap1: \"./admin/page1\", ap2: \"./admin/page2\" &#125;, output: &#123; filename: \"[name].js\" &#125;, plugins: [ new CommonsChunkPlugin(\"admin-commons.js\", [\"ap1\", \"ap2\"]), new CommonsChunkPlugin(\"commons.js\", [\"p1\", \"p2\", \"admin-commons.js\"]) ]&#125;;// 在不同页面用&lt;script&gt;标签引入如下js:// page1.html: commons.js, p1.js// page2.html: commons.js, p2.js// page3.html: p3.js// admin-page1.html: commons.js, admin-commons.js, ap1.js// admin-page2.html: commons.js, admin-commons.js, ap2.js 这种用法有点像gulp或grunt中手动将多个js合并为common, 但是在webpack里，这个过程是全自动生成的，不用我们自己分析代码的依赖关系。但是这种按需加载的弊端也十分明显，需要人工配置需要提取的文件。另外一个插件是uglifyJsPlugin，用于压缩js代码。 我们还用到一个字段是 devtool, 用于配置开发工具。‘source-map’就是在生成的代码中加入sourceMap的支持。能够直接定位到出错代码的具体位置，对sourcemap的使用和原理还不了解的可以看下这篇文章。另外，devtool的配置参数使用在这里。 如何加载第三方库？在pc开发中我们通常会用到jQuery库。如何很好地处理这类文件呢？这里有两种办法。 方法一 是在html中用script标签引入js文件，如 1&lt;script src=\"https://code.jquery.com/jquery-git2.min.js\"&gt;&lt;/script&gt; 然后再配置文件中添加externals 1externals: &#123; jquery: \"jQuery\" &#125; 该字段的作用是将加jQuery全局变量变为模块可引入。然后在各个模块中，就可以如下使用： 1var $ = require(\"jquery\"); 我个人觉得既然已经将加jQuery通过script引入了，那么就直接使用$标签就行了。不必再将其转化为模块。 方法二 是将jQuery代码保存到本地，在配置文件中添加： 1resolve: &#123; alias: &#123; jquery: \"/path/to/jquery-git2.min.js\" &#125; &#125; 即为jquery添加了别名，然后在模块中也是这样使用： 1var $ = require(\"jquery\"); 还可以配合使用ProvidePlugin，其作用是提供全局变量给每个模块，这样就不需要在模块中通过require引入，例如：使用前: 12var _ = require(\"underscore\");_.size(...); 使用后： 12345678plugins: [ new webpack.ProvidePlugin(&#123; \"_\": \"underscore\" &#125;)]// If you use \"_\", underscore is automatically required_.size(...) 总的来说，如果文件来自CDN，那么使用方法一，如果文件在本地，则用方法二。 gulp足够优秀目前来说，我们只利用webpack进行了js方面的打包，其他功能用gulp就足够了。gulp主要做了下面几个工作： css转化合并压缩 图片的雪碧图合并和base64 文件md5计算与替换 热启动，浏览器自动刷新 下列是依赖的npm模块： 1234567891011121314151617\"devDependencies\": &#123; \"gulp\": \"^3.8.10\", \"gulp-clean\": \"0.3.1\", \"gulp-concat\": \"2.6.0\", \"gulp-connect\": \"2.2.0\", \"gulp-css-base64\": \"^1.3.2\", \"gulp-css-spriter\": \"^0.3.3\", \"gulp-cssmin\": \"0.1.7\", \"gulp-file-include\": \"0.13.7\", \"gulp-less\": \"3.0.3\", \"gulp-md5-plus\": \"0.1.8\", \"gulp-open\": \"1.0.0\", \"gulp-uglify\": \"1.4.2\", \"gulp-util\": \"~2.2.9\", \"gulp-watch\": \"4.1.0\", \"webpack\": \"~1.0.0-beta6\" &#125;, 支持雪碧图合并和base64我对gulp-css-spriter和gulp-css-base64的源码做了一点修改，使其支持下面的语法： 123.icon_corner_new&#123; background-image: url(../images/new-ico.png?__sprite);&#125; 如果在url的后面加上__sprite后缀,则插件将会把该图片合并到雪碧图里。可以支持一个css文件合并为一个雪碧图，也可以整站合并。 123.icon_corner_new&#123; background-image: url(../images/new-ico.png?__inline);&#125; 如果加上后缀__inline,则会将图片转化为base64,直接添加到css文件中，对于几k的小文件可以直接使用inline操作。具体配置代码如下： 123456789101112131415gulp.task('sprite', function (done) &#123; var timestamp = +new Date(); gulp.src('dist/css/style.min.css') .pipe(spriter(&#123; spriteSheet: 'dist/images/spritesheet' + timestamp + '.png', pathToSpriteSheetFromCSS: '../images/spritesheet' + timestamp + '.png', spritesmithOptions: &#123; padding: 10 &#125; &#125;)) .pipe(base64()) // .pipe(cssmin()) .pipe(gulp.dest('dist/css')) .on('end', done);&#125;); src为需要处理的css文件，spriteSheet为雪碧图生成的目标文件夹，pathToSpriteSheetFromCSS为css文件中url的替换字符串，spritesmithOptions是生成雪碧图的间隙。 文件加md5, 实现发布更新发版本的时候为了避免浏览器读取了旧的缓存文件，需要为其添加md5戳。这里采用了gulp-md5-plus 123456gulp.task('md5:js', function (done) &#123; gulp.src('dist/js/*.js') .pipe(md5(10, 'dist/app/*.html')) .pipe(gulp.dest('dist/js')) .on('end', done);&#125;); 该代码会将dist/js下面所有的js计算md5戳，并将dist/app/下的html中script中的src引用文件名替换为加了md5的文件名，再将md5文件替换到目标目录dist/js。css的md5操作跟js无异。 关于服务器启动和代码转换的功能点，这里就不展开讲了。","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"JavaScript深入之执行上下文","date":"2017-07-04T01:12:56.000Z","path":"2017/07/04/JavaScript深入之执行上下文/","text":"在上篇JavaScript深入之执行上下文栈中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 思考题123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 这俩段代码到底哪里不一样呢，然后就在JavaScript深入之执行上下文栈中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。 具体执行分析我们分析第一段代码：123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 123ECStack = [ globalContext]; 2.全局上下文初始化 12345globalContext = &#123; VO: [global, scope, checkscope], Scope: [globalContext.VO], this: globalContext.VO&#125; 2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO ]; 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext ]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]1234567891011checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined &#125; 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 12345ECStack = [ fContext, checkscopeContext, globalContext ]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 123456789fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined &#125; 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 1234ECStack = [ checkscopeContext, globalContext ]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 123ECStack = [ globalContext]; 第二段代码的执行过程很以上同理。123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()();","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript时间戳和日期字符串相互转换","date":"2017-07-03T06:12:56.000Z","path":"2017/07/03/javascript时间戳和日期字符串相互转换/","text":"12345// 获取当前时间戳(以s为单位)var timestamp = Date.parse(new Date());timestamp = timestamp / 1000;//当前时间戳为：1403149534console.log(\"当前时间戳为：\" + timestamp); 123456// 获取某个时间格式的时间戳var stringTime = \"2014-07-10 10:21:12\";var timestamp2 = Date.parse(new Date(stringTime));timestamp2 = timestamp2 / 1000;//2014-07-10 10:21:12的时间戳为：1404958872 console.log(stringTime + \"的时间戳为：\" + timestamp2); 时间戳转日期格式123456&lt;script&gt; function getLocalTime(nS) &#123; return new Date(parseInt(nS) * 1000).toLocaleString().replace(/:\\d&#123;1,2&#125;$/,' '); &#125; alert(getLocalTime(1293072805)); &lt;/script&gt; 结果是 2010-12-23 10:53123456 &lt;script&gt; function getLocalTime(nS) &#123; return new Date(parseInt(nS) * 1000).toLocaleString().replace(/年|月/g, \"-\").replace(/日/g, \" \"); &#125; alert(getLocalTime(1177824835)); &lt;/script&gt; 结果是 2010年12月23日 10:53 12console.log(Date.parse(new Date('2017-07-03 23:59:59')) / 1000); //转为时间戳console.log(new Date(parseInt(1499097599) * 1000).toLocaleString()); //转为日期","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JavaScript深入之变量对象","date":"2017-07-01T01:12:56.000Z","path":"2017/07/01/JavaScript深入之变量对象/","text":"在上篇JavaScript深入之执行上下文栈中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO)作用域链(Scope chain)this今天重点讲讲创建变量对象的过程。 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。 函数上下文函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行过程执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 1.进入执行上下文2.代码执行 进入执行上下文当进入执行上下文时，这时候还没有执行代码， 变量对象会包括： 1.函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined 2.函数声明由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建如果变量对象已经存在相同名称的属性，则完全替换这个属性 3.变量声明由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。 举个例子：12345678910function foo(a) &#123; var b = 2; function c() &#123;&#125; var d = function() &#123;&#125;; b = 3;&#125;foo(1); 在进入执行上下文后，这时候的 AO 是：12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, c: reference to function c()&#123;&#125;, d: undefined&#125; 代码执行在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值 还是上面的例子，当代码执行完后，这时候的 AO 是：12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference to function c()&#123;&#125;, d: reference to FunctionExpression \"d\"&#125; 到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说： 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 在代码执行阶段，会再次修改变量对象的属性值 思考123456789101112function foo() &#123; console.log(a); a = 1;&#125;foo(); // ???function bar() &#123; a = 1; console.log(a);&#125;bar(); // ??? 第一段会报错：Uncaught ReferenceError: a is not defined。 第二段会打印：1。 这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。 第一段执行 console 的时候， AO 的值是：12345AO = &#123; arguments: &#123; length: 0 &#125;&#125; 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。 1234567console.log(foo);function foo()&#123; console.log(\"foo\");&#125;var foo = 1; 会打印函数，而不是 undefined 。 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JavaScript深入之执行上下文栈","date":"2017-07-01T00:12:56.000Z","path":"2017/07/01/JavaScript深入之执行上下文栈/","text":"顺序执行？如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟：123456789101112131415var foo = function () &#123; console.log('foo1');&#125;foo(); // foo1var foo = function () &#123; console.log('foo2');&#125;foo(); // foo2 然而去看这段代码：123456789101112131415function foo() &#123; console.log('foo1');&#125;foo(); // foo2function foo() &#123; console.log('foo2');&#125;foo(); // foo2 打印的结果却是两个 foo2。刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？ 到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？ 可执行代码这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？ 其实很简单，就三种，全局代码、函数代码、eval代码。 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。 执行上下文栈接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： 1ECStack = []; 试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：123ECStack = [ globalContext]; 现在 JavaScript 遇到下面的这段代码了：12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3();&#125;function fun1() &#123; fun2();&#125;fun1(); 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：123456789101112131415161718192021// 伪代码// fun1()ECStack.push(&lt;fun1&gt; functionContext);// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext);// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext);// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 实例好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，让我们来看下面的例子123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 答案就是执行上下文栈的变化不一样。 模拟第一段的执行上下文1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop(); 模拟第二段的执行上下文1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 是不是有些不同呢？ 当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇JavaScript深入之变量对象。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript中的Function和Object","date":"2017-06-29T02:10:24.000Z","path":"2017/06/29/javascript中的Function和Object/","text":"在JavaScript中所有的对象都继承自Object原型，而Function又充当了对象的构造器，那么Funtion和Object到底有着什麽样的关系呢 ？首先，一切都是对象。1234alert(Object instanceof Object); // true alert(Function instanceof Object);// true alert(Object instanceof Function);// true alert(Function instanceof Function);// true 由此可见，Object继承自己，Funtion继承自己，Object和Function互相是继承对方，也就是说Object和Function都既是函数也是对象。这一点很特别。所有的函数都是对象，可是并不是所有的对象都是函数。证明如下：1234function foo()&#123;&#125;; alert(foo instanceof Function); // true alert(foo instanceof Object); // true alert(new foo() instanceof Function); // false 我们看到由new + function的构造器实例化出来的对象不是函数，仅仅是Object的子类。接下来，我们会想所有的对象都有一个Function的构造器存储在原型链的constructor属性中，那么Object的构造器是什麽呢？ 证明：12alert(Object.constructor); // function Function()&#123; [native code] &#125; alert(Function.constructor); // function Function()&#123; [native code] &#125; 由此我们可以确定Object是由Function这个函数为原型的，而Function是由它自己为原型的。Function函数是由native code构成的，我们不用去深究了。存在function Function(){…}的定义，我们明白了Function其实就是函数指针，也看作函数变量。就相当于function foo(){}中的foo。连Object的构造器都是指向Function的，可以想象Function是一个顶级的函数定义，大大的区别于自定义的如function foo(){}这样的函数定义。 看这样一个语句，new Function();以Function为原型来实例化一个对象，按照刚才Object.constructor 为 functon Function(){}来说，new Function()产生的对象应该是一个Object啊，我们来验证一下：1234alert(new Function() instanceof Object); // true alert(Object instanceof new Function());// false alert(typeof new Function());// function alert(typeof Object);// function 其实new Function();将产生一个匿名函数，由于Function是顶级函数所以可以产生自定义函数，我们可以把所有的函数看作Function的子类。但所有的一切包括函数都是Object的子类这点是不变的，也得到了体现。typeof Object的结果说明Object也是一个函数。继续做实验：1alert(new Object().constructor); // function Object()&#123; [native code] &#125; 一个情理之中的疑惑。可以这么说凡是可以放在new后面的都是一个函数构造器，那么Object确实也像其它函数一样，是一个函数的指针或者是函数变量，但Function是顶级的所以Object要由Function来构造。可以这么理解，Function和Object一个是上帝，一个是撒旦同时诞生于宇宙的最开始，拥相当的力量。但是上帝更为光明，所以高高在上。Object要由Function来构造，Function属于顶级函数。但是撒旦并没有绝对的输给上帝，否则上帝就会消灭撒旦。于是或所有的对象都要继承Object包括Function(Object和Function既是对象又是函数)。就相当于所有的人包括上帝都有邪念一样。 拓展一下，由Object我们会想到Array,Number,String等这些内置对象。有理由相信这些都是Object的子类。如下：123456alert(Array instanceof Object) // true alert(String instanceof Object) // true alert(Number instanceof Object) // true alert(Object instanceof Array) // false alert(Object instanceof String) // false alert(Object instanceof Number) // false 当然他们也都会有Object的特性就像魔鬼和撒旦的关系一样，也是Function的子类，由Function构造。那么有Array,String,Number构造的对像如：new Array();new Number();new String()的构造器是function Array(){…};function String(){…};function Number(){…};123456alert(Array instanceof Function) // true alert(String instanceof Function) // true alert(Number instanceof Function) // true alert(Array.constructor) // function Function()&#123; [native code] &#125; alert(String.constructor) // function Function()&#123; [native code] &#125; alert(Number.constructor) // function Function()&#123; [native code] &#125; 总结一下，像内置的函数或说对象把如:Object,String,Array等等和自定义的function关键字定义的函数,都是Function的子类。new Function()相当于function关键字定义。这里可以引出，Function.prototype原型链上的属性所有函数共享,Object.prototype原型链上的属性所有对象共享。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"http之响应篇","date":"2017-06-21T07:10:24.000Z","path":"2017/06/21/http之响应篇/","text":"一个http响应代表服务器给浏览器回送的数据，同时告诉浏览器该如何处理数据。 基本结构1.状态行2.消息头信息3.实体信息 先看一段响应信息123456789101112131415161718//200 ok 表示客户端已经请求成功HTTP/1.1 200 OK//告诉浏览器请求页面的时间Date: Wed, 21 Jun 2017 05:54:22 GMT//告诉浏览器服务器的情况Server: Apache/2.4.23 (Win32) OpenSSL/1.0.2j mod_fcgid/2.3.9//文档类型Content-Type: text/html; charset=UTF-8//缓存Cache-controll:private//目标间隔时间和重定向跳转地址Refresh: 3;url=http://localhost/http/2.php//下面3个共同来控制该页面是否需要被缓存（为什么呢？ 因为浏览器种类有很多种）Expires:-1Cache-controll:no-cachePragma:no-cache 状态码100 ~ 199 表示成功接收请求，要求客户端继续提交下次请求才能完成整个处理过程 200 ~ 299 表示成功接收请求并已完成整个过程，常用200 300 ~ 399 为完成请求，客户需进一步细化请求，例如，请求的资源已经移到一个新的网址，常用304 302 400 ~ 499 客户端请求有错误，常用404 500 ~ 599 服务器内部出现错误，常用500 304码一般都是缓存机制。 PHP禁用缓存如何通过http响应控制页面缓存，在默认情况下，浏览器会缓存页面。123header(\"Expires:-1\");header(\"Cache-controll:no-cache\");header(\"Pragma:no-cache\");","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"http之请求篇","date":"2017-06-21T01:10:24.000Z","path":"2017/06/21/http之请求篇/","text":"一个http请求，是由三部分组成的，1、请求行2、消息头3、实体内容 先来看一段请求12345678910111213141516//表示发送的是get请求，请求的资源是1.phpGET /http/1.php HTTP/1.1//表示客户端可以接收哪些数据类型Accept: text/html, application/xhtml+xml, */*//表示 我是从哪里来的（可以做防盗链，很有用，一般是连接过来才有）Referer: http://localhost/http/1.php//页面可以支持什么语言Accept-Language: zh-CN//告诉服务器我的浏览器的版本User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)//表示接收什么样的数据压缩格式Accept-Encoding: gzip, deflate//主机Host: localhost//连接形式(长连接，表示不要立马断掉我们的请求)Connection: Keep-Alive 这段请求中1GET /http/1.php HTTP/1.1 称之为请求行 下面的内容1234567Accept: text/html, application/xhtml+xml, */*Accept-Language: zh-CNUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)UA-CPU: AMD64Accept-Encoding: gzip, deflateHost: localhostConnection: Keep-Alive 称之为 消息头 最后剩下一个实体内容（也称为 一个空行）","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"es6之Set和WeakSet","date":"2017-06-13T07:11:24.000Z","path":"2017/06/13/es6之Set和WeakSet/","text":"SetES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构。12345678var s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向Set结构加入成员，结果表明Set结构不会添加重复的值。 Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。1234567891011121314151617181920// 例一var set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;var set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。 上面代码中，也展示了一种去除数组重复成员的方法。12// 去除数组的重复成员[...new Set(array)] 向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。在Set内部，两个NaN是相等。 Set实例的属性和方法Set结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。Set.prototype.size：返回Set实例的成员总数。Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回Set结构本身。delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。has(value)：返回一个布尔值，表示该值是否为Set的成员。clear()：清除所有成员，没有返回值。上面这些属性和方法的实例如下。1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false Array.from方法可以将Set结构转为数组。12var items = new Set([1, 2, 3, 4, 5]);var array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作Set结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回一个键名的遍历器values()：返回一个键值的遍历器entries()：返回一个键值对的遍历器forEach()：使用回调函数遍历每个成员key方法、value方法、entries方法返回的都是遍历器对象。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"] Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。12Set.prototype[Symbol.iterator] === Set.prototype.values// true 这意味着，可以省略values方法，直接用for…of循环遍历Set。 WeakSetWeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。 首先，WeakSet的成员只能是对象，而不能是其他类型的值。 其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。 12345var ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set 上面代码试图向WeakSet添加一个数值和Symbol值，结果报错，因为WeakSet只能放置对象。 WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。 1var ws = new WeakSet(); 作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。 WeakSet结构有以下三个方法。 WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。下面是一个例子。123456789101112var ws = new WeakSet();var obj = &#123;&#125;;var foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false WeakSet没有size属性，没有办法遍历它的成员。 WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"JavaScript中defer的作用","date":"2017-06-13T05:10:24.000Z","path":"2017/06/13/JavaScript中defer的作用/","text":"很多人都已经把 Javascript的用的炉火纯青了，但见到defer未必就知道他是做什么用的；很多人也都遇到过这样的问题，需要直接执行别且操作DOM对象的js 总是报找不到对象的错误，原因大家也都知道就是页面还有没有加载完毕，js的操作对象还在下载中。但很多人都不知道，添加defer标签就能轻而易举的解决这个问题。123456789101112131415161718&lt;script src=\"../CGI-bin/delscript.js\" defer&gt;&lt;/script&gt;中的defer作用是文档加载完毕了再执行脚本,这样回避免找不到对象的问题---有点问题&lt;button id=\"myButton\" onclick=\"alert('ok')\"&gt;test&lt;/button&gt;&lt;script&gt;myButton.click();&lt;/script&gt;&lt;script&gt;myButton.click();&lt;/script&gt;&lt;button id=\"myButton\" onclick=\"alert('ok')\"&gt;test&lt;/button&gt;&lt;script defer&gt;function document.body.onload() &#123;alert(document.body.offsetHeight);&#125;&lt;/script&gt; 加上 defer 等于在页面完全在入后再执行，相当于 window.onload ，但应用上比 window.onload 更灵活！defer是脚本程序强大功能中的一个“无名英雄”。它告诉浏览器Script段包含了无需立即执行的代码，并且，与SRC属性联合使用，它还可以使这些脚本在后台被下载，前台的内容则正常显示给用户。–但是 文档加载完毕了再执行脚本 请注意两点：1、不要在defer型的脚本程序段中调用document.write命令，因为document.write将产生直接输出效果。2、而且，不要在defer型脚本程序段中包括任何立即执行脚本要使用的全局变量或者函数。 一个常用的优化性能的方法是：当脚本不需要立即运行时，在&lt;SCRIPT&gt;标签中设置“defer”属性。 (立即脚本没有被包含在一个function块中,因此会在加载过程中执行。) 设置“defer”属性后，IE就不必等待该脚本装载和执行完毕。这样页面加载会更快。一般来说，这也表明立即脚本最好放在function块中，并在 document或者body对象的onload 句柄中处理该函数。在有一些脚本需要依赖用户操作而执行时—-例如点击按钮，或者移动鼠标到某个区域—-使用该属性非常有用。但当有一些脚本需要在页面加载过程中或加载完成后执行，使用defer属性得到的好处就不太大。 script中的defer属性默认情况下是false的。按照DHTML编程宝典中的描述，对于Defer属性是这样写的：Using the attribute at design time can improve the download performance of a page because the browser does not need to parse and execute the script and can continue downloading and parsing the page instead.也就是说：如果是编写脚本的时候加入defer属性，那么浏览器在下载脚本的时候就不必立即对其进行处理，而是继续对页面进行下载和解析，这样会提高下载的性能。这样的情况有很多种。比如你定义了很多javascript变量，或者在引用文件（.inc）中写了很多的脚本需要处理，那不妨在这些脚本中加入defer属性，对性能的提高肯定有所帮助。举例如下：1234&lt;script language=\"javascript\" defer&gt;var object = new Object();....&lt;/script&gt; 因为defer属性默认是为false的，那么在这里1&lt;script language=\"javascript\" defer&gt; 显式声明defer属性后等同于1&lt;script language=\"javascript\" defer=true&gt; 声明了defer属性之后，需要判断是否有别的变量引用了defer脚本块中的变量，否则的话会导致脚本错误的产生。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"es6之数组扩展","date":"2017-06-08T11:10:24.000Z","path":"2017/06/08/es6之数组扩展/","text":"Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] Array.from方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefinded ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.of()Array.of方法用于将一组值，转换为数组。123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 数组实例的copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。这三个参数都应该是数值，如果不是，会自动转为数值。12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。12[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 上面代码找出数组中第一个小于0的成员。数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。1234[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 数组实例的fill()fill方法使用给定值，填充一个数组。12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\"","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"es6之Promise","date":"2017-06-07T01:11:24.000Z","path":"2017/06/07/es6之Promise/","text":"所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。 Promise也有一些缺点。 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。 基本用法Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。123456789var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。123456getJSON(\"/posts.json\").then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。1234567p.then((val) =&gt; console.log(\"fulfilled:\", val)) .catch((err) =&gt; console.log(\"rejected:\", err));// 等同于p.then((val) =&gt; console.log(fulfilled:\", val)) .then(null, (err) =&gt; console.log(\"rejected:\", err)); 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。 Promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。1var p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。） p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。12345678910// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON(\"/post/\" + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); 上面代码中，promises是包含6个Promise实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"es6之箭头函数","date":"2017-06-07T01:10:24.000Z","path":"2017/06/07/es6之箭头函数/","text":"基本语法ES6允许使用“箭头”（=&gt;）定义函数。12345var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。1var getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 箭头函数可以与变量解构结合使用。12345const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 使用注意点箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量,另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: 'inner' &#125;)() ];&#125;).call(&#123; x: 'outer' &#125;);// ['outer'] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 箭头函数与常规函数对比一个箭头函数与一个普通的函数在两个方面不一样： 下列变量的构造是词法的： arguments ， super ， this ， new.target不能被用作构造函数：没有内部方法 [[Construct]] （该方法允许普通的函数通过 new 调用），也没有 prototype 属性。因此， new (() =&gt; {}) 会抛出错误。除了那些意外，箭头函数和普通的函数没有明显的区别。例如， typeof 和 instanceof 产生同样的结果：123456789typeof () =&gt; &#123;&#125;//'function'() =&gt; &#123;&#125; instanceof Function//truetypeof function () &#123;&#125;//'function'function () &#123;&#125; instanceof Function//true 函数表达式和对象字面量是例外，这种情形下必须放在括号里面，因为它们看起来像是函数声明和代码块。","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"JavaScript之FileReader接口","date":"2017-06-06T07:10:24.000Z","path":"2017/06/06/JavaScript之FileReader接口/","text":"记得以前做网站时，曾经需要实现一个图片上传到服务器前，先预览的功能。当时用html的file标签一直实现不了，最后舍弃了这个标签，使用了其他方式来实现了这个功能。今天无意发现了一个知识点，用html的file标签就能实现图片上传前预览，感觉很棒，记录一下！就是通过file标签和js的FileReader接口，把选择的图片文件调用readAsDataURL方法，把图片数据转成base64字符串形式显示在页面上。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div style=\"border:2px dashed red;\"&gt; &lt;p&gt; 图片上传前预览：&lt;input type=\"file\" id=\"xdaTanFileImg\" onchange=\"xmTanUploadImg(this)\"/&gt; &lt;/p&gt; &lt;img id=\"xmTanImg\"/&gt; &lt;div id=\"xmTanDiv\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;hr /&gt; &lt;script type=\"text/javascript\"&gt; //判断浏览器是否支持FileReader接口 if (typeof FileReader == 'undefined') &#123; document.getElementById(\"xmTanDiv\").InnerHTML = \"&lt;h1&gt;当前浏览器不支持FileReader接口&lt;/h1&gt;\"; //使选择控件不可操作 document.getElementById(\"xdaTanFileImg\").setAttribute(\"disabled\", \"disabled\"); &#125; //选择图片 function xmTanUploadImg(obj) &#123; var file = obj.files[0]; console.log(obj);console.log(file); console.log(\"file.size = \" + file.size); //file.size 单位为byte var reader = new FileReader(); //读取文件过程方法 reader.onloadstart = function (e) &#123; console.log(\"开始读取....\"); &#125; reader.onprogress = function (e) &#123; console.log(\"正在读取中....\"); &#125; reader.onabort = function (e) &#123; console.log(\"中断读取....\"); &#125; reader.onerror = function (e) &#123; console.log(\"读取异常....\"); &#125; reader.onload = function (e) &#123; console.log(\"成功读取....\"); var img = document.getElementById(\"xmTanImg\"); img.src = e.target.result; //或者 img.src = this.result; //e.target == this &#125; //图片数据转成base64字符串形式。 reader.readAsDataURL(file) &#125; &lt;/script&gt; 另外 FileReader除了有函数readAsDataURL，另外还有另外两个函数readAsBinaryString 和 readAsText，分别可以将选择的文件读取成二进制和文本格式 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script type=\"text/javascript\"&gt; //判断浏览器是否支持FileReader接口 if (typeof FileReader == 'undefined') &#123; document.getElementById(\"xmTanContentDiv\").InnerHTML = \"&lt;p&gt;当前浏览器不支持FileReader接口！&lt;/p&gt;\"; document.getElementById(\"xmTanFile\").setAttribute(\"disabled\", \"disabled\"); &#125; //选择文件 function xmTanUploadFile(obj)&#123; if (obj.files.length &lt; 1) return; var file = obj.files[0]; if (file.size &gt; 1024 * 1024) &#123; alert(\"文件大于1M， 太大了，小点吧！\"); obj.value = \"\"; return; &#125; &#125; //读取文件为二进制 function readAsBinaryString() &#123; var obj = document.getElementById(\"xmTanFile\"); if (obj.files.length &lt; 1) return; var file = obj.files[0]; var reader = new FileReader(); //将文件以二进制形式读入页面 reader.readAsBinaryString(file); reader.onload = function (f) &#123; document.getElementById(\"xmTanContentDiv\").innerHTML = this.result; &#125; &#125; //读取文件为文本 function readAsText() &#123; var obj = document.getElementById(\"xmTanFile\"); if (obj.files.length &lt; 1) return; var file = obj.files[0]; var reader = new FileReader(); //将文件以文本形式读入页面 reader.readAsText(file); reader.onload = function (f) &#123; document.getElementById(\"xmTanContentDiv\").innerHTML = this.result; &#125; &#125; &lt;/script&gt; &lt;div style=\"border: 2px dashed red; padding: 20px 0px;\"&gt; &lt;label&gt;选择文件：&lt;/label&gt; &lt;input type=\"file\" id=\"xmTanFile\" accept=\".html,.js,.css,.txt,.cs,.xml\" onchange=\"xmTanUploadFile(this)\"/&gt; &lt;input type=\"button\" value=\"读取成二进制数据\" onclick=\"readAsBinaryString()\" /&gt; &lt;input type=\"button\" value=\"读取成文本数据\" onclick=\"readAsText()\" /&gt; &lt;input type=\"button\" value=\"隐藏读取内容\" onclick=\"document.getElementById('xmTanContentDiv').style.display = 'none';\"/&gt; &lt;input type=\"button\" value=\"显示读取内容\" onclick=\"document.getElementById('xmTanContentDiv').style.display = 'block';\"/&gt; &lt;div id=\"xmTanContentDiv\"&gt;&lt;/div&gt; &lt;/div&gt;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"webpack+vue模块化构建项目","date":"2017-06-02T06:12:24.000Z","path":"2017/06/02/webpack+vue模块化构建项目/","text":"开始(确认已经安装node环境和npm包管理工具)拓展：npm install 在安装 npm 包时，有两种命令参数可以把它们的信息写入 package.json 文件，一个是npm install –save ，另一个是 npm install –save-dev，他们表面上的区别是–save 会把依赖包名称添加到 package.json 文件 dependencies 键下，–save-dev 则添加到 package.json 文件 devDependencies 键下，–save-dev 是你开发时候依赖的东西，–save 是你发布之后还依赖的东西。12345678910111、新建项目文件名为demo2、npm init -y 初始化项目3、npm install --save vue 默认安装最新版vue4、npm install --save-dev webpack webpack-dev-server //安装webpack，webpack-dev-server（一个小型服务器）5、npm install --save-dev babel-core babel-loader babel-preset-es2015 //安装babel的作用是将es6的语法编译成浏览器认识的语法es56、npm install --save-dev vue-loader vue-template-compiler //用来解析vue的组件，.vue后缀的文件7、npm install --save-dev css-loader style-loader //用来解析css8、npm install --save-dev url-loader file-loader //用于打包文件和图片9、npm install --save-dev sass-loader node-sass //用于编译sass以下等等(省略) 项目目录结构123456789101112131415demo-src--assets---img---sass---style--components---...--views //这里放详情页面---...--App.vue--main.js-index.html-package.json-webpack.config.js package.json12345678910111213141516171819202122232425262728293031&#123; \"name\": \"demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --open --hot\", \"build\": \"webpack\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"vue\": \"^2.3.3\" &#125;, \"devDependencies\": &#123; \"babel-core\": \"^6.24.1\", \"babel-loader\": \"^7.0.0\", \"babel-preset-es2015\": \"^6.24.1\", \"cross-env\": \"^5.0.0\", \"css-loader\": \"^0.28.4\", \"file-loader\": \"^0.11.1\", \"style-loader\": \"^0.18.1\", \"url-loader\": \"^0.5.8\", \"vue-loader\": \"^12.2.1\", \"vue-template-compiler\": \"^2.3.3\", \"webpack\": \"^2.6.1\", \"webpack-dev-server\": \"^2.4.5\" &#125;&#125; webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: 'build.js' &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; &#125; &#125; &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.(png|jpg|gif|svg)$/, loader: 'file-loader', options: &#123; name: '[name].[ext]?[hash]' &#125; &#125; , &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" &#125; ] &#125;, resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' &#125; &#125;, devServer: &#123; historyApiFallback: true, noInfo: true, inline: true &#125;, performance: &#123; hints: false &#125;, devtool: '#eval-source-map'&#125;if (process.env.NODE_ENV === 'production') &#123; module.exports.devtool = '#source-map' // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '\"production\"' &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: true, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;) ])&#125; 这里webpack配置文件不明白的，可以看 webpack入门，至于更多的配置，可百度。 项目跑起来1231、webpack2、webpack-dev-server 转换npm命令1npm install cross-env --save-dev package.json文件配置添加：12\"dev\": \"cross-env NODE_ENV=development webpack-dev-server --open --hot\",\"build\": \"webpack\"","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"webpack之sass-loader模块加载","date":"2017-06-01T06:12:24.000Z","path":"2017/06/01/webpack之sass-loader模块加载/","text":"为了使用sass，我们需要安装sass的依赖包。1234$ npm install --save-dev sass-loader$ npm install --save-dev node-sass //sass-loader依赖于node-sass，所以还要安装node-sass 当然了，使用样式的话，css-loader和style-loader也是必须的依赖包，如果没有安装，可以类似上述的方法安装 css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能；style-loader将所有的计算后的样式加入页面中； 二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 webpack配置中的配置只列举sass配置,前提是已经装了 css-loader和style-loader 并且已经配置12345678910&#123; test: /\\.scss$/, use: [&#123; loader: \"style-loader\" // creates style nodes from JS strings &#125;, &#123; loader: \"css-loader\" // translates CSS into CommonJS &#125;, loader: \"sass-loader\" // compiles Sass to CSS &#125;]&#125; 使用方法123import '../../css/test.scss'require('../../css/test2.scss'); 文件中使用123&lt;style lang=\"scss\"&gt;&lt;/style&gt;","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"php ajax跨域问题最佳解决方案","date":"2017-05-26T08:10:24.000Z","path":"2017/05/26/php ajax跨域问题最佳解决方案/","text":"本文通过设置Access-Control-Allow-Origin来实现跨域,例如：客户端的域名是client.runoob.com，而请求的域名是server.runoob.com。如果直接使用ajax访问，会有以下错误：1XMLHttpRequest cannot load http://server.runoob.com/server.php. No 'Access-Control-Allow-Origin' header is present on the requested resource.Origin 'http://client.runoob.com' is therefore not allowed access. 1、允许单个域名访问指定某域名http://client.runoob.com跨域访问，则只需在http://server.runoob.com/server.php文件头部添加如下代码：1header('Access-Control-Allow-Origin:http://client.runoob.com'); 2、允许多个域名访问指定多个域名 http://client1.runoob.com、 http://client2.runoob.com等跨域访问，则只需在http://server.runoob.com/server.php文件头部添加如下代码：12345678910$origin = isset($_SERVER['HTTP_ORIGIN'])? $_SERVER['HTTP_ORIGIN'] : ''; $allow_origin = array( 'http://client1.runoob.com', 'http://client2.runoob.com' ); if(in_array($origin, $allow_origin))&#123; header('Access-Control-Allow-Origin:'.$origin); &#125; 3、允许所有域名访问允许所有域名访问则只需在http://server.runoob.com/server.php文件头部添加如下代码：1header('Access-Control-Allow-Origin:*');","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"axios使用","date":"2017-05-25T16:10:24.000Z","path":"2017/05/26/axios在项目中的使用方法/","text":"在VUE2.0出来以后，官方就不推荐使用vue-resource了，而是使用axios ,使用方法都大同小异，在项目中有俩种使用方法，教程地址: axios 第一种(配置文件)这里使用的是vue-webpack脚手架，在src目录下，新建一个api目录，里面分别创建这俩个文件 api.js / config.js,详情看代码。 api.js123456789101112131415import axios from 'axios' //导入axios模块import config from './config' //导入配置文件import qs from 'qs'//axios(config);class API &#123; getList (param) &#123; console.log(config); //这里打印的是配置文件中的信息 //发送请求 return axios.post(config.url,&#123; id:param &#125;) &#125;&#125;export default API; config.js //这里配置信息可参考上面的连接地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import Qs from 'qs'export default&#123; // `url` is the server URL that will be used for the request url: 'http://localhost:80/cms/getinfo.php', // `method` is the request method to be used when making the request method: 'get', // default // `baseURL` will be prepended to `url` unless `url` is absolute. // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs // to methods of that instance. baseURL: 'https://some-domain.com/api/', // `transformRequest` allows changes to the request data before it is sent to the server // This is only applicable for request methods 'PUT', 'POST', and 'PATCH' // The last function in the array must return a string or an instance of Buffer, ArrayBuffer, // FormData or Stream transformRequest: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // `transformResponse` allows changes to the response data to be made before // it is passed to then/catch transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // `headers` are custom headers to be sent headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, headers: &#123;'Content-Type': 'application/x-www-form-urlencoded'&#125;, // `params` are the URL parameters to be sent with the request // Must be a plain object or a URLSearchParams object params: &#123; ID: 12345 &#125;, // `paramsSerializer` is an optional function in charge of serializing `params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` is the data to be sent as the request body // Only applicable for request methods 'PUT', 'POST', and 'PATCH' // When no `transformRequest` is set, must be of one of the following types: // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream, Buffer data: &#123; firstName: 'Fred' &#125;, // `timeout` specifies the number of milliseconds before the request times out. // If the request takes longer than `timeout`, the request will be aborted. timeout: 1000, // `withCredentials` indicates whether or not cross-site Access-Control requests // should be made using credentials withCredentials: false, // default // `adapter` allows custom handling of requests which makes testing easier. // Return a promise and supply a valid response (see lib/adapters/README.md). adapter: function (config) &#123; /* ... */ &#125;, // `auth` indicates that HTTP Basic auth should be used, and supplies credentials. // This will set an `Authorization` header, overwriting any existing // `Authorization` custom headers you have set using `headers`. auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` indicates the type of data that the server will respond with // options are 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress` allows handling of progress events for uploads onUploadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `onDownloadProgress` allows handling of progress events for downloads onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength` defines the max size of the http response content allowed maxContentLength: 2000, // `validateStatus` defines whether to resolve or reject the promise for a given // HTTP response status code. If `validateStatus` returns `true` (or is set to `null` // or `undefined`), the promise will be resolved; otherwise, the promise will be // rejected. validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects` defines the maximum number of redirects to follow in node.js. // If set to 0, no redirects will be followed. maxRedirects: 5, // default &#125; 组件中调用12import API from '../api/API' //导入模块let api = new API() //实例化对象，然后对象调用不同的方法。 第二种方法(组件注入试)在src中的main.js做如下配置12import axios from 'axios'; //导入模块Vue.prototype.$http = axios; // 把axios的信息赋值到$http上，我们组件中就可以使用 this.$http方法 以上就是俩种使用方法，不过目前我还没解决跨域问题，如果有知道的可以告诉我一下。","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-lazyload图片懒加载","date":"2017-05-24T16:10:24.000Z","path":"2017/05/25/vue-lazyload图片懒加载/","text":"支持1.0和2.0 使用案例1$ npm install vue-lazyload --save-dev 12345678910111213141516171819202122//主文件 main.js import Vue from 'vue'import App from './App.vue'// for Vue 1.0import VueLazyload from 'vue-lazyload'// for Vue 2.0import VueLazyload from 'vue-lazyload/vue-lazyload-next'Vue.use(VueLazyload, &#123; error: 'dist/error.png', loading: 'dist/loading.gif', try: 3 // default 1&#125;)new Vue(&#123; el: 'body', components: &#123; App &#125;&#125;) 12345678910111213141516171819202122232425262728293031323334//组件中&lt;script&gt;export default &#123; data () &#123; return &#123; list: [ 'your_images_url', 'your_images_url', 'your_images_url' ] &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;div class=\"img-list\"&gt; &lt;ul id=\"container\"&gt; &lt;li v-for=\"img in list\"&gt; &lt;img v-lazy=\"img\"&gt; &lt;/li&gt; &lt;!-- for custom container &lt;li v-for=\"img in list\"&gt; &lt;img v-lazy.container=\"img\"&gt; &lt;/li&gt; for background-image &lt;li v-for=\"img in list\"&gt; &lt;div v-lazy:background-image=\"img\" class=\"bg-box\"&gt;&lt;/div&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"JavaScript之原型详解","date":"2017-05-24T00:10:24.000Z","path":"2017/05/24/JavaScript之原型详解/","text":"本篇文章主要介绍的是函数对象中的原型(prototype)属性,对于JavaScript,理解原型是一个非常重要的环节，所以我今天把自己的经验分享出来，先看一段代码。 原型属性123456function foo(a,b)&#123;&#125;console.log(foo.lenght); //输出2console.log(foo.constructor); //输出Functionconsole.log(typeof foo.constructor); //输出Object 以上的代码，其实在函数定义时就被创建了，属性中就包括prototype属性，它的初始值是一个空的对象。当然我们也可以自己添加属性，如:1foo.prototype = &#123;&#125; 我们可以赋予这个空对象一些属性和方法，并且与foo函数本身不会造成什么影响。 利用原型添加属性和方法定义一个构造函数，并用构造函数来创建出构造对象，这种的做法是通过new关键字返回一个函数的对象，利用这个对象就可以调用this返回其对象的方法或者属性，这样就有了一种赋予对象一种新的方法或者属性的功能。1234567891011121314function Gadget(name,color)&#123; this.name = name; this.color = color; this.say = function()&#123; return this.name + this.color; &#125;&#125;Gadget.prototype = &#123; price:100, rating:3, getInfo:function()&#123; return this.price + this.rating; &#125;&#125; 向原型中添加完属性和方法之后，就可以访问了，这里构造函数自身的属性优先级要高于原型的属性。12345var newtoy = new Gadget('yuexing','blue');console.log(newtoy.say()); //输出 yuexing blueconsole.log(newtoy.name); //输出yuexingconsole.log(newtoy.price); //输出100console.log(newtoy.getInfo()); //输出100 3 对于原型来说，最重要的一个概念就是“驻留”，由于在javascrit中，对象都是通过引用方式来传递值的，也就是传递的实际是一个地址，因此我们所创建的对象中的原型，没有一份属于自己的原型副本，这就意味着我们随时可以对原型进行添加和修改，并且对象会继承者原型这一切的改变。12345Gadget.prototype.get = function(what)&#123; return this[what];&#125;var newtoy = new Gadget('yuexing','blue');console.log(newtoy.get('price')); //输出100 自身属性和原型属性在之前的getInfo方法中，我你们用的是this指针来完成对象访问的，但是执行使用Gadget.prototype也可以直接访问,这难道有什么不同么？当我们访问newtoy的某个属性的时候，JavaScript引擎会遍历该对象的所有属性，并查找一个叫name 和 color的属性，如果找到了就立即返回值，如果找不到，Javascrit引擎就会去查询创建当前对象的原型属性，等价于我们直接访问（Gadget.prototype），如果在原型中找到了就立即返回原型中的值，这个结构会一直持续下去，并且最终取决于原型链的长度，但其最后肯定是Object对象，因为他是最高级的父级对象。至于它为什么会向上查找，因为这里有一个神秘的_ proto _的属性，下节再说这个属性。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"vue之全面理解MVVM模式","date":"2017-05-23T06:12:24.000Z","path":"2017/05/23/vue之全面理解MVVM模式/","text":"之前一直对MVVM这个模式有点模糊，虽然也能做出项目，但是总感觉欠缺点什么东西，所以今天特意回来看了一下vue的这个MVVM，其实理解了还是蛮简单的，可能我一直遵循的是MVC和MCP的这种思想，所有这种思想转变的还是挺难受的。 关于MVVMvue集中在MVVM模式上的视图模型(ViewModel)层，并且通过双向数据绑定连接视图(View)和模型(Model)，实际的DOM操作和输出格式被抽象出来成指令和过滤器，看一个最简单的例子。 1234// 这是我们的 View&lt;div id=\"example-1\"&gt; Hello &#123;&#123; name &#125;&#125;!&lt;/div&gt; 1234// 这是我们的 Modelvar exampleData = &#123; name: 'Vue.js'&#125; 123456// 创建一个 Vue 实例或 \"ViewModel\"// 它连接 上面的View 与 Modelvar exampleVM = new Vue(&#123; el: '#example-1', data: exampleData&#125;) 这里的ViewModel连接着View和Model，因为我们只要修改ViewModel中的data数据，上面的Model和View会自动响应数据的变化。","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-scroller列表上拉下拉加载更多","date":"2017-05-22T14:10:24.000Z","path":"2017/05/22/vue-scroller列表上拉下拉加载更多/","text":"我个人觉得官方例子特别好,直接上案例: 链接地址 演示地址 demo的使用方法12$ npm install$ npm run dev 在项目中的使用123$import Vue from 'vue'$import VueScroller from 'vue-scroller'$Vue.use(VueScroller) 源码说明以下例子中，你只需要看我标注的函数即可,我们可以理解为钩子函数，实际项目中我们只会用到这几个函数，至于其余的代码均为官方提供。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div class=\"header\"&gt; &lt;h1 class=\"title\"&gt;Refresh &amp; Infinite&lt;/h1&gt; &lt;/div&gt; &lt;scroller style=\"top: 44px\" :on-refresh=\"refresh\" :on-infinite=\"infinite\"&gt; &lt;div v-for=\"(item, index) in items\" class=\"row\" :class=\"&#123;'grey-bg': index % 2 == 0&#125;\"&gt; &#123;&#123; item &#125;&#125; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Vue from 'vue' import VueScroller from 'vue-scroller' Vue.use(VueScroller) export default &#123; data() &#123; return &#123; items: [] &#125; &#125;, mounted() &#123; // 默认初始化加载 for (var i = 1; i &lt;= 20; i++) &#123; this.items.push(i + ' - keep walking, be 2 with you.') &#125; this.top = 1 this.bottom = 20 &#125;, methods: &#123; //上拉加载函数 refresh (done) &#123; setTimeout(() =&gt; &#123; var start = this.top - 1 for (var i = start; i &gt; start - 10; i--) &#123; this.items.splice(0, 0, i + ' - keep walking, be 2 with you.') &#125; this.top = this.top - 10 done() &#125;, 1500) &#125;, infinite (done) &#123; //下拉加载函数 setTimeout(() =&gt; &#123; var start = this.bottom + 1 for (var i = start; i &lt; start + 10; i++) &#123; this.items.push(i + ' - keep walking, be 2 with you.') &#125; this.bottom = this.bottom + 10 done() &#125;, 1500) &#125; &#125; &#125;&lt;/script&gt;","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-roter路由在项目中的使用思路。","date":"2017-05-19T03:10:24.000Z","path":"2017/05/19/vue-router在项目中如何正确配置/","text":"之前做了一个项目，做到文章详情页的时候发现可以跳转到文章详情页，但是导航不会随之消失，后来发现这就是我路由没有配置好的问题，现在把这个正确的配置放上来，基本的大部分app都大同小异。 正确导航的一个配置 看例子1234567891011121314151617181920212223242526272829routes: [ &#123; path: '/', redirect: &#123; name: 'Nav' &#125; //默认跳转到导航组件 &#125;, &#123; path:'/Nav', //导航组件 （网站导航组件） name:'Nav', component:Nav, redirect: &#123; name: 'About' &#125;, //跳转到about组件 （可以看做是文章列表组件） children:[ &#123; path:'/Home/:id', name:'Home', component:Home &#125;, &#123; path:'/About/:id', name:'About', component:About &#125; ] &#125;, &#123; path:'/Where', //文章内容页面组件 name:'Where', component:Where, &#125; ] 在导航Nav组件里面的配置1234567&#123;&lt;div class=\"nav\"&gt; //点击跳转对应的路由组件 &lt;router-link :to=\"&#123;name:'About',params:&#123;id:1&#125;&#125;\"&gt;Home&lt;/router-link&gt; &lt;router-link :to=\"&#123;name:'About',params:&#123;id:2&#125;&#125;\"&gt;About&lt;/router-link&gt; //用于显然的列表 &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&#125; 在文章里列表组件中，可以利用$router.push(‘组件名’)跳转到相应的文章内容组件，并且导航是不会显示的。 至于如何通过不同的ID来切换相同组件的数据，可以看我上一篇文章。","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-cli通过参数动态更新组件内容","date":"2017-05-18T13:10:24.000Z","path":"2017/05/18/vue-cli通过参数动态更新组件内容/","text":"平时开发时候都是一个导航对应一个组件，现在有一个需求，就是点击不同的导航（通过ID传递），更换不同的内容，而组件的样式都是一样的，这时候就需要用到这个了。 同一个组件通过参数动态渲染的做法vue-router中提供了一个导航钩子的方法 beforeRouteUpdate(to, from, next),这个方法很有用，意思就是在当前路由改变，但是该组件被复用时调用。 if/for语句中），它在代码块外是可以被访问的。 123beforeRouteUpdate(to, from, next)&#123; //这里可以动态渲染我们想要的数据,就不需要一个导航对应一个组件了。&#125; 其他方法当然还有其他方法也可以实现，就是通过监听的方法，大概的思路就是监听我们传递过来的这个ID，如果这个这个ID发生变化了，然后就重新获取内容。 12345watch:&#123; id(传递过来的值:比如我是id) ()&#123; //里面写判断的业务逻辑 &#125;&#125;","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"JavaScript之闭包详解篇","date":"2017-05-17T12:42:56.000Z","path":"2017/05/17/JavaScript之闭包详解篇/","text":"再看本篇之前需要有作用域的知识，如果您还不懂作用域，请看本人上一篇文章 JavaScript之作用域详解篇 利用闭包突破作用域链上篇文章中我们说到了可以利用闭包突破作用域链，那么首先我来介绍一个闭包这个概念，先上代码。 1234567var a = 1;function f()&#123; var b =2; function n()&#123; var c = 3; &#125;&#125; 首先我说一下全局作用域，可以将其看做是一个包含一切的宇宙，其中可以包含各种变量和函数等等，但是每个函数也有一个自己的作用域，用于存储一些别的变量和函数，现在我们假设a变量在全局作用域中，变量b在函数f()作用域中，变量c在函数n()作用域中,但是n函数也在f()函数作用域中，在这里呢，我们可以访问的作用域为全局，函数f()，函数n(),其中变量a和变量b之间是不连通的，因为变量b在函数f()以外是不可见的，但是我们可以将变量c和变量b连通起来，或者也可以说将函数n()和变量b连接起来，当我们将函数n()的作用域扩展到f()以外，并且止步于全局空间以内的时候，这个时候就产生了闭包。 函数n()会和变量a一样，置身于全局作用域，而且函数有一个特点，就是说它还记得被定义时所处于的环境，因此，它仍然可以访问函数f()作用域中的b变量,因为现在函数n和变量a都处于同一个作用域，但是函数n()可以访问变量b，但是变量a则不可以。 例子下面我们来看一个函数 123456function f()&#123; var b = 'b'; return function()&#123; return b; &#125;&#125; 这个函数含有了一个局部变量b，它在全局是不可见的， 12console.log(b);输出：b is not defined 接下来我们看一个函数f的返回值，它是另外的一个函数,我们可以把它看成是上面讲的函数n，该函数有自己的私用空间，同时也可以访问函数f()的空间和全局空间，所以变量b对他来说是可见的，因为函数f()时可以在全局中被调用的（它是一个全局函数），所以我们可以把它的返回值赋值给另外的一个全局变量，这个时候呢就生成了一个可以访问函数f()私有空间的一个新的全局函数，直接看代码。 123var n = f();console.log(n());输出:b 今天先写这么多，更深层次的后面再讲。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JavaScript之作用域链详解篇","date":"2017-05-16T13:10:24.000Z","path":"2017/05/16/JavaScript之作用域详解篇/","text":"对于初学者来说接触javascript可能会有一些困难，本人是在回顾之前的知识以后才对这个概念有了一些自己的理解，所以今天也将自己的一些理解记录下来，本人第一次写文章，不喜勿喷，后续大部分的文章都与作用域链有关，所以这是一个很重要的概念。 作用域链大家都知道，JavaScript跟许多程序设计语言都不太一样，它不存在大括号级的作用域（不包括ES6），但是它有函数作用域，也就是说，在函数内定义的变量在函数外部是不能被访问的，但是如果该变量是在某个代码块中定义的（如 if/for语句中），它在代码块外是可以被访问的。 123456789var a = 1;function f()&#123; var b = 1; return a;&#125;console.log(f());输出：1console.log(b);报错了：b is not defined 在这里，变量a是属于全局作用域的，而变量b的作用域就在函数f()内了，所以，也就印证了上面我们说的是没有错的。 另外，如果我们在函数f()中定义了另外一个函数n()，那么，在函数n()中可以访问的变量可以是来自他自身的作用域，也可以来自其”父级”（f()）的作用域，这也就形成了一条作用域链，该链的长度取决于我们具体的需求。 1234567var a = 1;function f()&#123; var b = 1; function n()&#123; var c = 3; &#125;&#125; 词法作用域在javascript中，每一个函数都有一个自己的词法作用域，也就是说，每个函数在定义的时候（非执行时）都会创建一个属于自己的环境（即作用域）。 123456789function f1()&#123; var a =1; f2();&#125;function f2()&#123; return a;&#125;console.log(f1());输出:a is not defined 在上面的代码中，我们在函数f1()中调用了函数f2(),由于局部变量a也在f1()中，所以我们可能会认为函数f2()是能够访问a的，但是事实不是这样，因为当函数f2()被定义的时候,变量a是不可见的，和函数f1()一样，它那个时候只能访问自身作用域和全局作用域中的内容，也就是说，这里的f1()和f2()之间不存在共享的词法作用域，所以，接下来就可以利用闭包这个机制来突破作用域链，至于闭包详解篇，下篇在分享，再声明一次，本人第一次写文章，欢迎大牛指正。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]